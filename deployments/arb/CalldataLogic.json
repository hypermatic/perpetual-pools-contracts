{
  "address": "0xb4D3147bcd1A6eBD83947f52E172dD1c6eed4be5",
  "abi": [],
  "transactionHash": "0x1b7ec401af21f2027f9277062d88904cf328bd545ff98433817da696e5b651b1",
  "receipt": {
    "to": null,
    "from": "0xCC97EB5651e05D5a0Ae8bcD2813B9DFDaD6F92a5",
    "contractAddress": "0xb4D3147bcd1A6eBD83947f52E172dD1c6eed4be5",
    "transactionIndex": 0,
    "gasUsed": "746907",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x2ce89c511a8be8a1414d3b8897fa3ec86187ee59931cb247d61aaebf973cd067",
    "transactionHash": "0x1b7ec401af21f2027f9277062d88904cf328bd545ff98433817da696e5b651b1",
    "logs": [],
    "blockNumber": 13387395,
    "cumulativeGasUsed": "152127",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "solcInputHash": "4b024dc169a046e6527f075e446ec886",
  "metadata": "{\"compiler\":{\"version\":\"0.8.7+commit.e28d00a7\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"title\":\"CalldataLogic library\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Library to decode calldata, used to optimize calldata size in PerpetualPools for L2 transaction cost reduction\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/libraries/CalldataLogic.sol\":\"CalldataLogic\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/interfaces/IPoolCommitter.sol\":{\"content\":\"//SPDX-License-Identifier: CC-BY-NC-ND-4.0\\npragma solidity 0.8.7;\\n\\n/// @title The interface for the contract that handles pool commitments\\ninterface IPoolCommitter {\\n    /// Type of commit\\n    enum CommitType {\\n        ShortMint, // Mint short tokens\\n        ShortBurn, // Burn short tokens\\n        LongMint, // Mint long tokens\\n        LongBurn, // Burn long tokens\\n        LongBurnShortMint, // Burn Long tokens, then instantly mint in same upkeep\\n        ShortBurnLongMint // Burn Short tokens, then instantly mint in same upkeep\\n    }\\n\\n    function isMint(CommitType t) external pure returns (bool);\\n\\n    function isBurn(CommitType t) external pure returns (bool);\\n\\n    function isLong(CommitType t) external pure returns (bool);\\n\\n    function isShort(CommitType t) external pure returns (bool);\\n\\n    // Pool balances and supplies\\n    struct BalancesAndSupplies {\\n        uint256 newShortBalance;\\n        uint256 newLongBalance;\\n        uint256 longMintPoolTokens;\\n        uint256 shortMintPoolTokens;\\n        uint256 longBurnInstantMintSettlement;\\n        uint256 shortBurnInstantMintSettlement;\\n        uint256 totalLongBurnPoolTokens;\\n        uint256 totalShortBurnPoolTokens;\\n    }\\n\\n    // User aggregate balance\\n    struct Balance {\\n        uint256 longTokens;\\n        uint256 shortTokens;\\n        uint256 settlementTokens;\\n    }\\n\\n    // Token Prices\\n    struct Prices {\\n        bytes16 longPrice;\\n        bytes16 shortPrice;\\n    }\\n\\n    // Commit information\\n    struct Commit {\\n        uint256 amount;\\n        CommitType commitType;\\n        uint40 created;\\n        address owner;\\n    }\\n\\n    // Commit information\\n    struct TotalCommitment {\\n        uint256 longMintSettlement;\\n        uint256 longBurnPoolTokens;\\n        uint256 shortMintSettlement;\\n        uint256 shortBurnPoolTokens;\\n        uint256 shortBurnLongMintPoolTokens;\\n        uint256 longBurnShortMintPoolTokens;\\n    }\\n\\n    // User updated aggregate balance\\n    struct BalanceUpdate {\\n        uint256 _updateIntervalId;\\n        uint256 _newLongTokensSum;\\n        uint256 _newShortTokensSum;\\n        uint256 _newSettlementTokensSum;\\n        uint256 _longSettlementFee;\\n        uint256 _shortSettlementFee;\\n        uint8 _maxIterations;\\n    }\\n\\n    // Track how much of a user's commitments are being done from their aggregate balance\\n    struct UserCommitment {\\n        uint256 longMintSettlement;\\n        uint256 longBurnPoolTokens;\\n        uint256 shortMintSettlement;\\n        uint256 shortBurnPoolTokens;\\n        uint256 shortBurnLongMintPoolTokens;\\n        uint256 longBurnShortMintPoolTokens;\\n        uint256 updateIntervalId;\\n    }\\n\\n    // Track the relevant data when executing a range of update interval's commitments (stack too deep)\\n    struct CommitmentExecutionTracking {\\n        uint256 longTotalSupply;\\n        uint256 shortTotalSupply;\\n        uint256 longTotalSupplyBefore;\\n        uint256 shortTotalSupplyBefore;\\n        uint256 _updateIntervalId;\\n    }\\n\\n    /**\\n     * @notice Creates a notification when a commit is created\\n     * @param user The user making the commitment\\n     * @param amount Amount of the commit\\n     * @param commitType Type of the commit (Short v Long, Mint v Burn)\\n     * @param appropriateUpdateIntervalId Id of update interval where this commit can be executed as part of upkeep\\n     * @param fromAggregateBalance whether or not to commit from aggregate (unclaimed) balance\\n     * @param payForClaim whether or not to request this commit be claimed automatically\\n     * @param mintingFee Minting fee at time of commit creation\\n     */\\n    event CreateCommit(\\n        address indexed user,\\n        uint256 indexed amount,\\n        CommitType indexed commitType,\\n        uint256 appropriateUpdateIntervalId,\\n        bool fromAggregateBalance,\\n        bool payForClaim,\\n        bytes16 mintingFee\\n    );\\n\\n    /**\\n     * @notice Creates a notification when a user's aggregate balance is updated\\n     */\\n    event AggregateBalanceUpdated(address indexed user);\\n\\n    /**\\n     * @notice Creates a notification when the PoolCommitter's leveragedPool address has been updated.\\n     * @param newPool the address of the new leveraged pool\\n     */\\n    event PoolChanged(address indexed newPool);\\n\\n    /**\\n     * @notice Creates a notification when commits for a given update interval are executed\\n     * @param updateIntervalId Unique identifier for the relevant update interval\\n     * @param burningFee Burning fee at the time of commit execution\\n     */\\n    event ExecutedCommitsForInterval(uint256 indexed updateIntervalId, bytes16 burningFee);\\n\\n    /**\\n     * @notice Creates a notification when a claim is made, depositing pool tokens in user's wallet\\n     */\\n    event Claim(address indexed user);\\n\\n    /*\\n     * @notice Creates a notification when the burningFee is updated\\n     */\\n    event BurningFeeSet(uint256 indexed _burningFee);\\n\\n    /**\\n     * @notice Creates a notification when the mintingFee is updated\\n     */\\n    event MintingFeeSet(uint256 indexed _mintingFee);\\n\\n    /**\\n     * @notice Creates a notification when the changeInterval is updated\\n     */\\n    event ChangeIntervalSet(uint256 indexed _changeInterval);\\n\\n    /**\\n     * @notice Creates a notification when the feeController is updated\\n     */\\n    event FeeControllerSet(address indexed _feeController);\\n\\n    // #### Functions\\n\\n    function initialize(\\n        address _factory,\\n        address _autoClaim,\\n        address _factoryOwner,\\n        address _feeController,\\n        address _invariantCheck,\\n        uint256 mintingFee,\\n        uint256 burningFee,\\n        uint256 _changeInterval\\n    ) external;\\n\\n    function commit(bytes32 args) external payable;\\n\\n    function updateIntervalId() external view returns (uint128);\\n\\n    function pendingMintSettlementAmount() external view returns (uint256);\\n\\n    function pendingShortBurnPoolTokens() external view returns (uint256);\\n\\n    function pendingLongBurnPoolTokens() external view returns (uint256);\\n\\n    function claim(address user) external;\\n\\n    function executeCommitments(\\n        uint256 lastPriceTimestamp,\\n        uint256 updateInterval,\\n        uint256 longBalance,\\n        uint256 shortBalance\\n    )\\n        external\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n\\n    function updateAggregateBalance(address user) external;\\n\\n    function getAggregateBalance(address user) external view returns (Balance memory _balance);\\n\\n    function getAppropriateUpdateIntervalId() external view returns (uint128);\\n\\n    function setPool(address _leveragedPool) external;\\n\\n    function setBurningFee(uint256 _burningFee) external;\\n\\n    function setMintingFee(uint256 _mintingFee) external;\\n\\n    function setChangeInterval(uint256 _changeInterval) external;\\n\\n    function setFeeController(address _feeController) external;\\n}\\n\",\"keccak256\":\"0x6e61f689295ef4339452ac1ba5347d1e933d2ef231ca5d1a4a89ef94a506234b\",\"license\":\"CC-BY-NC-ND-4.0\"},\"contracts/libraries/CalldataLogic.sol\":{\"content\":\"//SPDX-License-Identifier: CC-BY-NC-ND-4.0\\npragma solidity 0.8.7;\\n\\nimport \\\"../interfaces/IPoolCommitter.sol\\\";\\n\\n/// @title CalldataLogic library\\n/// @notice Library to decode calldata, used to optimize calldata size in PerpetualPools for L2 transaction cost reduction\\nlibrary CalldataLogic {\\n    /*\\n     * Calldata when parameter is a tightly packed byte array looks like this:\\n     * -----------------------------------------------------------------------------------------------------\\n     * | function signature | offset of byte array | length of byte array |           bytes array           |\\n     * |      4 bytes       |       32 bytes       |       32 bytes       |  20 * number_of_addresses bytes |\\n     * -----------------------------------------------------------------------------------------------------\\n     *\\n     * If there are two bytes arrays, then it looks like\\n     * ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\\n     * | function signature | offset of 1st byte array | offset of 2nd byte array | length of 1st byte array |        1st bytes array          | length of 2nd byte array |        2nd bytes array          |\\n     * |      4 bytes       |        32 bytes          |        32 bytes          |         32 bytes         |  20 * number_of_addresses bytes |         32 bytes         |  20 * number_of_addresses bytes |\\n     * ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\\n     * and so on...\\n     * Note that the offset indicates where the length is indicated, and the actual array itself starts 32 bytes after that\\n     */\\n    // Length of address = 20\\n    uint16 internal constant ADDRESS_LENGTH = 20;\\n\\n    function getAddressAtOffset(uint256 offset) internal pure returns (address) {\\n        bytes20 addressAtOffset;\\n        assembly {\\n            addressAtOffset := calldataload(offset)\\n        }\\n        return (address(addressAtOffset));\\n    }\\n\\n    /**\\n     * @notice decodes compressed commit params to standard params\\n     * @param args The packed commit args\\n     * @return The amount of settlement or pool tokens to commit\\n     * @return The CommitType\\n     * @return Whether to make the commitment from user's aggregate balance\\n     * @return Whether to pay for an autoclaim or not\\n     */\\n    function decodeCommitParams(bytes32 args)\\n        internal\\n        pure\\n        returns (\\n            uint256,\\n            IPoolCommitter.CommitType,\\n            bool,\\n            bool\\n        )\\n    {\\n        uint256 amount;\\n        IPoolCommitter.CommitType commitType;\\n        bool fromAggregateBalance;\\n        bool payForClaim;\\n\\n        // `amount` is implicitly capped at 128 bits.\\n        assembly {\\n            amount := and(args, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\n            commitType := and(shr(128, args), 0xFF)\\n            fromAggregateBalance := and(shr(136, args), 0xFF)\\n            payForClaim := and(shr(144, args), 0xFF)\\n        }\\n        return (amount, commitType, fromAggregateBalance, payForClaim);\\n    }\\n}\\n\",\"keccak256\":\"0x9fef7490d395734483ba2e80c0439a24b8198cf13c0c2de2a52941b83456681d\",\"license\":\"CC-BY-NC-ND-4.0\"}},\"version\":1}",
  "bytecode": "0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122061e93671b91e0a71e355e8a464ad76a7d25273a30c509ecf729346e19cb013ee64736f6c63430008070033",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122061e93671b91e0a71e355e8a464ad76a7d25273a30c509ecf729346e19cb013ee64736f6c63430008070033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "title": "CalldataLogic library",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "notice": "Library to decode calldata, used to optimize calldata size in PerpetualPools for L2 transaction cost reduction",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}