{
  "address": "0x928d5a6668Bc9b801229c176c0bEB3b34Afba5d8",
  "abi": [
    {
      "inputs": [],
      "name": "MAX_DECIMALS",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "ONE",
      "outputs": [
        {
          "internalType": "bytes16",
          "name": "",
          "type": "bytes16"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "WAD_PRECISION",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes16",
          "name": "x",
          "type": "bytes16"
        },
        {
          "internalType": "bytes16",
          "name": "y",
          "type": "bytes16"
        }
      ],
      "name": "addBytes",
      "outputs": [
        {
          "internalType": "bytes16",
          "name": "",
          "type": "bytes16"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "timestamp",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "lastPriceTimestamp",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "frontRunningInterval",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "updateInterval",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "currentUpdateIntervalId",
          "type": "uint256"
        }
      ],
      "name": "appropriateUpdateIntervalId",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "longBalance",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "shortBalance",
          "type": "uint256"
        },
        {
          "internalType": "bytes16",
          "name": "leverageAmount",
          "type": "bytes16"
        },
        {
          "internalType": "int256",
          "name": "oldPrice",
          "type": "int256"
        },
        {
          "internalType": "int256",
          "name": "newPrice",
          "type": "int256"
        },
        {
          "internalType": "bytes16",
          "name": "fee",
          "type": "bytes16"
        }
      ],
      "name": "calculateValueTransfer",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes16",
          "name": "x",
          "type": "bytes16"
        },
        {
          "internalType": "bytes16",
          "name": "y",
          "type": "bytes16"
        }
      ],
      "name": "compareDecimals",
      "outputs": [
        {
          "internalType": "int8",
          "name": "",
          "type": "int8"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes16",
          "name": "ratio",
          "type": "bytes16"
        }
      ],
      "name": "convertDecimalToUInt",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "convertUIntToDecimal",
      "outputs": [
        {
          "internalType": "bytes16",
          "name": "",
          "type": "bytes16"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "int256",
          "name": "a",
          "type": "int256"
        },
        {
          "internalType": "int256",
          "name": "b",
          "type": "int256"
        }
      ],
      "name": "divInt",
      "outputs": [
        {
          "internalType": "bytes16",
          "name": "",
          "type": "bytes16"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_wadValue",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_decimals",
          "type": "uint256"
        }
      ],
      "name": "fromWad",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "reward",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "shortBalance",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "longBalance",
          "type": "uint256"
        }
      ],
      "name": "getBalancesAfterFees",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes16",
          "name": "price",
          "type": "bytes16"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "getBurn",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes16",
          "name": "lossMultiplier",
          "type": "bytes16"
        },
        {
          "internalType": "uint256",
          "name": "balance",
          "type": "uint256"
        }
      ],
      "name": "getLossAmount",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes16",
          "name": "ratio",
          "type": "bytes16"
        },
        {
          "internalType": "int8",
          "name": "direction",
          "type": "int8"
        },
        {
          "internalType": "bytes16",
          "name": "leverage",
          "type": "bytes16"
        }
      ],
      "name": "getLossMultiplier",
      "outputs": [
        {
          "internalType": "bytes16",
          "name": "",
          "type": "bytes16"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes16",
          "name": "price",
          "type": "bytes16"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "getMint",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenSupply",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amountIn",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "balance",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "pendingBurnPoolTokens",
          "type": "uint256"
        }
      ],
      "name": "getMintAmount",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "sideBalance",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "tokenSupply",
          "type": "uint256"
        }
      ],
      "name": "getPrice",
      "outputs": [
        {
          "internalType": "bytes16",
          "name": "",
          "type": "bytes16"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_numerator",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_denominator",
          "type": "uint256"
        }
      ],
      "name": "getRatio",
      "outputs": [
        {
          "internalType": "bytes16",
          "name": "",
          "type": "bytes16"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "bytes16",
              "name": "longPrice",
              "type": "bytes16"
            },
            {
              "internalType": "bytes16",
              "name": "shortPrice",
              "type": "bytes16"
            },
            {
              "internalType": "bytes16",
              "name": "mintingFeeRate",
              "type": "bytes16"
            },
            {
              "internalType": "uint256",
              "name": "currentUpdateIntervalId",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "updateIntervalId",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "longMintSettlement",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "longBurnPoolTokens",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "shortMintSettlement",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "shortBurnPoolTokens",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "longBurnShortMintPoolTokens",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "shortBurnLongMintPoolTokens",
              "type": "uint256"
            },
            {
              "internalType": "bytes16",
              "name": "burnFee",
              "type": "bytes16"
            }
          ],
          "internalType": "struct PoolSwapLibrary.UpdateData",
          "name": "data",
          "type": "tuple"
        }
      ],
      "name": "getUpdatedAggregateBalance",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "_newLongTokens",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_newShortTokens",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_longSettlementFee",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_shortSettlementFee",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_newSettlementTokens",
              "type": "uint256"
            }
          ],
          "internalType": "struct PoolSwapLibrary.UpdateResult",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenSupply",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amountIn",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "balance",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "pendingBurnPoolTokens",
          "type": "uint256"
        }
      ],
      "name": "getWithdrawAmountOnBurn",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "subjectTime",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "lastPriceTimestamp",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "updateInterval",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "frontRunningInterval",
          "type": "uint256"
        }
      ],
      "name": "isBeforeFrontRunningInterval",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes16",
          "name": "feeRate",
          "type": "bytes16"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "mintingOrBurningFee",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "number",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "numerator",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "denominator",
          "type": "uint256"
        }
      ],
      "name": "mulFraction",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes16",
          "name": "x",
          "type": "bytes16"
        },
        {
          "internalType": "bytes16",
          "name": "y",
          "type": "bytes16"
        }
      ],
      "name": "multiplyBytes",
      "outputs": [
        {
          "internalType": "bytes16",
          "name": "",
          "type": "bytes16"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes16",
          "name": "a",
          "type": "bytes16"
        },
        {
          "internalType": "uint256",
          "name": "b",
          "type": "uint256"
        }
      ],
      "name": "multiplyDecimalByUInt",
      "outputs": [
        {
          "internalType": "bytes16",
          "name": "",
          "type": "bytes16"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "bytes16",
          "name": "burnPrice",
          "type": "bytes16"
        },
        {
          "internalType": "bytes16",
          "name": "burningFee",
          "type": "bytes16"
        },
        {
          "internalType": "bytes16",
          "name": "mintingFee",
          "type": "bytes16"
        }
      ],
      "name": "processBurnInstantMintCommit",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes16",
          "name": "x",
          "type": "bytes16"
        },
        {
          "internalType": "bytes16",
          "name": "y",
          "type": "bytes16"
        }
      ],
      "name": "subtractBytes",
      "outputs": [
        {
          "internalType": "bytes16",
          "name": "",
          "type": "bytes16"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "transactionHash": "0xfd0ae571ec7edcff932e4994ba415fa0bcda7720154df8936e5220441b2525da",
  "receipt": {
    "to": null,
    "from": "0xfb59B91646cd0890F3E5343384FEb746989B66C7",
    "contractAddress": "0x928d5a6668Bc9b801229c176c0bEB3b34Afba5d8",
    "transactionIndex": 0,
    "gasUsed": "45842321",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x933dbe1dee69196454d1acf6fde212b45b243e9eb2e34b5f4cbae5ec1c79677e",
    "transactionHash": "0xfd0ae571ec7edcff932e4994ba415fa0bcda7720154df8936e5220441b2525da",
    "logs": [],
    "blockNumber": 12184257,
    "cumulativeGasUsed": "22018001",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "solcInputHash": "ed877995a3a12fdfd020e943737872e5",
  "metadata": "{\"compiler\":{\"version\":\"0.8.7+commit.e28d00a7\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"MAX_DECIMALS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ONE\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WAD_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"x\",\"type\":\"bytes16\"},{\"internalType\":\"bytes16\",\"name\":\"y\",\"type\":\"bytes16\"}],\"name\":\"addBytes\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastPriceTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"frontRunningInterval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updateInterval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentUpdateIntervalId\",\"type\":\"uint256\"}],\"name\":\"appropriateUpdateIntervalId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"longBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shortBalance\",\"type\":\"uint256\"},{\"internalType\":\"bytes16\",\"name\":\"leverageAmount\",\"type\":\"bytes16\"},{\"internalType\":\"int256\",\"name\":\"oldPrice\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"newPrice\",\"type\":\"int256\"},{\"internalType\":\"bytes16\",\"name\":\"fee\",\"type\":\"bytes16\"}],\"name\":\"calculateValueTransfer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"x\",\"type\":\"bytes16\"},{\"internalType\":\"bytes16\",\"name\":\"y\",\"type\":\"bytes16\"}],\"name\":\"compareDecimals\",\"outputs\":[{\"internalType\":\"int8\",\"name\":\"\",\"type\":\"int8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"ratio\",\"type\":\"bytes16\"}],\"name\":\"convertDecimalToUInt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"convertUIntToDecimal\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"a\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"b\",\"type\":\"int256\"}],\"name\":\"divInt\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_wadValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_decimals\",\"type\":\"uint256\"}],\"name\":\"fromWad\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shortBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"longBalance\",\"type\":\"uint256\"}],\"name\":\"getBalancesAfterFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"price\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getBurn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"lossMultiplier\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"getLossAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"ratio\",\"type\":\"bytes16\"},{\"internalType\":\"int8\",\"name\":\"direction\",\"type\":\"int8\"},{\"internalType\":\"bytes16\",\"name\":\"leverage\",\"type\":\"bytes16\"}],\"name\":\"getLossMultiplier\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"price\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingBurnPoolTokens\",\"type\":\"uint256\"}],\"name\":\"getMintAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sideBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenSupply\",\"type\":\"uint256\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_numerator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_denominator\",\"type\":\"uint256\"}],\"name\":\"getRatio\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes16\",\"name\":\"longPrice\",\"type\":\"bytes16\"},{\"internalType\":\"bytes16\",\"name\":\"shortPrice\",\"type\":\"bytes16\"},{\"internalType\":\"bytes16\",\"name\":\"mintingFeeRate\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"currentUpdateIntervalId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updateIntervalId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"longMintSettlement\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"longBurnPoolTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shortMintSettlement\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shortBurnPoolTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"longBurnShortMintPoolTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shortBurnLongMintPoolTokens\",\"type\":\"uint256\"},{\"internalType\":\"bytes16\",\"name\":\"burnFee\",\"type\":\"bytes16\"}],\"internalType\":\"struct PoolSwapLibrary.UpdateData\",\"name\":\"data\",\"type\":\"tuple\"}],\"name\":\"getUpdatedAggregateBalance\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_newLongTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newShortTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_longSettlementFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_shortSettlementFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newSettlementTokens\",\"type\":\"uint256\"}],\"internalType\":\"struct PoolSwapLibrary.UpdateResult\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingBurnPoolTokens\",\"type\":\"uint256\"}],\"name\":\"getWithdrawAmountOnBurn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"subjectTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastPriceTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updateInterval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"frontRunningInterval\",\"type\":\"uint256\"}],\"name\":\"isBeforeFrontRunningInterval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"feeRate\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mintingOrBurningFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"number\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numerator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denominator\",\"type\":\"uint256\"}],\"name\":\"mulFraction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"x\",\"type\":\"bytes16\"},{\"internalType\":\"bytes16\",\"name\":\"y\",\"type\":\"bytes16\"}],\"name\":\"multiplyBytes\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"a\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"multiplyDecimalByUInt\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes16\",\"name\":\"burnPrice\",\"type\":\"bytes16\"},{\"internalType\":\"bytes16\",\"name\":\"burningFee\",\"type\":\"bytes16\"},{\"internalType\":\"bytes16\",\"name\":\"mintingFee\",\"type\":\"bytes16\"}],\"name\":\"processBurnInstantMintCommit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"x\",\"type\":\"bytes16\"},{\"internalType\":\"bytes16\",\"name\":\"y\",\"type\":\"bytes16\"}],\"name\":\"subtractBytes\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"addBytes(bytes16,bytes16)\":{\"params\":{\"x\":\"The number to be added with `y`\",\"y\":\"The number to be added with `x`\"}},\"appropriateUpdateIntervalId(uint256,uint256,uint256,uint256,uint256)\":{\"details\":\"Note that the timestamp parameter is required to be >= lastPriceTimestamp\",\"params\":{\"currentUpdateIntervalId\":\"The current update interval's ID\",\"frontRunningInterval\":\"The frontrunning interval of a pool - The amount of time before an update interval that you must commit to get included in that update\",\"lastPriceTimestamp\":\"The timestamp of the last price update\",\"timestamp\":\"Current block.timestamp\",\"updateInterval\":\"The frequency of a pool's updates\"},\"returns\":{\"_0\":\"The update interval ID in which a commit being made at time timestamp should be included\"}},\"calculateValueTransfer(uint256,uint256,bytes16,int256,int256,bytes16)\":{\"details\":\"This function should be called by the LeveragedPoolThe value transfer is calculated using a sigmoid functionThe sigmoid function used is defined as follows:          when newPrice >= oldPrice              losing_pool_multiplier = 2 / (1 + e^(-2 * L * (1 - (newPrice / oldPrice)))) - 1          when newPrice < oldPrice              losing_pool_multiplier = 2 / (1 + e^(-2 * L * (1 - (oldPrice / newPrice)))) - 1          where              e = euler's number              L = leverage              newPrice = the new oracle price              oldPrice = the previous oracle price\",\"params\":{\"fee\":\"The pool's annualised protocol fee\",\"leverageAmount\":\"The leverage of the pool\",\"longBalance\":\"Settlement token balance on the long side of the pool before the price change\",\"newPrice\":\"The new price\",\"oldPrice\":\"The previous price\",\"shortBalance\":\"Settlement token balance on the short side of the pool before the price change\"},\"returns\":{\"_0\":\"Resulting long balance\",\"_1\":\"Resulting short balance\",\"_2\":\"Resulting fees taken from long balance\",\"_3\":\"Resulting fees taken from short balance\"}},\"compareDecimals(bytes16,bytes16)\":{\"params\":{\"x\":\"The first number to compare\",\"y\":\"The second number to compare\"},\"returns\":{\"_0\":\"-1 if x < y, 0 if x = y, or 1 if x > y\"}},\"convertDecimalToUInt(bytes16)\":{\"params\":{\"ratio\":\"The value to convert\"},\"returns\":{\"_0\":\"The converted value\"}},\"convertUIntToDecimal(uint256)\":{\"params\":{\"amount\":\"The amount to convert\"},\"returns\":{\"_0\":\"The amount as a IEEE754 quadruple precision number\"}},\"divInt(int256,int256)\":{\"params\":{\"a\":\"The dividend\",\"b\":\"The divisor\"},\"returns\":{\"_0\":\"The quotient\"}},\"fromWad(uint256,uint256)\":{\"params\":{\"_decimals\":\"Quantity of decimal places to support\",\"_wadValue\":\"wad number\"},\"returns\":{\"_0\":\"Converted (non-WAD) value\"}},\"getBalancesAfterFees(uint256,uint256,uint256)\":{\"details\":\"Assumes shortBalance + longBalance >= reward\",\"params\":{\"longBalance\":\"Long balance of the pool\",\"reward\":\"Amount of keeper reward\",\"shortBalance\":\"Short balance of the pool\"},\"returns\":{\"_0\":\"shortBalanceAfterFees Short balance of the pool after the keeper reward has been paid\",\"_1\":\"longBalanceAfterFees Long balance of the pool after the keeper reward has been paid\"}},\"getBurn(bytes16,uint256)\":{\"details\":\"amount * price, where amount is in PoolToken and price is in USD/PoolTokenThrows if price is zero, or IEEE754 negative zero`getBurn()`\",\"params\":{\"amount\":\"Amount of pool tokens being used to burn\",\"price\":\"Price of a pool token\"},\"returns\":{\"_0\":\"Quantity of settlement tokens to return to the user after `amount` pool tokens are burnt.\"}},\"getLossAmount(bytes16,uint256)\":{\"params\":{\"balance\":\"The balance of the losing pool\",\"lossMultiplier\":\"The multiplier to use\"}},\"getLossMultiplier(bytes16,int8,bytes16)\":{\"params\":{\"direction\":\"The direction of the change. -1 if it's decreased, 0 if it hasn't changed, and 1 if it's increased\",\"leverage\":\"The amount of leverage to apply\",\"ratio\":\"The ratio of new price to old price\"},\"returns\":{\"_0\":\"The multiplier\"}},\"getMint(bytes16,uint256)\":{\"details\":\"Throws if price is zero, or IEEE754 negative zero`getMint()`\",\"params\":{\"amount\":\"Amount of settlement tokens being used to mint\",\"price\":\"Price of a pool token\"},\"returns\":{\"_0\":\"Quantity of pool tokens to mint\"}},\"getMintAmount(uint256,uint256,uint256,uint256)\":{\"details\":\"Calculated as (tokenSupply + shadowBalance) * amountIn / balance\",\"params\":{\"amountIn\":\"Commitment amount of settlement tokens going into the pool\",\"balance\":\"Balance of the pool (no. of underlying settlement tokens in pool)\",\"pendingBurnPoolTokens\":\"Amount of pool tokens being burnt during this update interval\",\"tokenSupply\":\"Total supply of pool tokens\"},\"returns\":{\"_0\":\"Number of pool tokens to be minted\"}},\"getPrice(uint256,uint256)\":{\"details\":\"Divide the side balance by the pool token's total supply\",\"params\":{\"sideBalance\":\"no. of underlying settlement tokens on that side of the pool\",\"tokenSupply\":\"Total supply of pool tokens\"}},\"getRatio(uint256,uint256)\":{\"details\":\"Rounds any overflow towards 0. If either parameter is zero, the ratio is 0\",\"params\":{\"_denominator\":\"The \\\"per part\\\" side of the equation. If this is zero, the ratio is zero\",\"_numerator\":\"The \\\"parts per\\\" side of the equation. If this is zero, the ratio is zero\"},\"returns\":{\"_0\":\"the ratio, as an ABDKMathQuad number (IEEE 754 quadruple precision floating point)\"}},\"getUpdatedAggregateBalance(PoolSwapLibrary.UpdateData)\":{\"params\":{\"data\":\"Information needed for updating the balance including prices and recent commit amounts\"},\"returns\":{\"_0\":\"The UpdateResult struct with the data pertaining to the update of user's aggregate balance\"}},\"getWithdrawAmountOnBurn(uint256,uint256,uint256,uint256)\":{\"details\":\"Calculates as `balance * amountIn / (tokenSupply + shadowBalance)\",\"params\":{\"amountIn\":\"Commitment amount of pool tokens going into the pool\",\"balance\":\"Balance of the pool (no. of underlying settlement tokens in pool)\",\"pendingBurnPoolTokens\":\"Amount of pool tokens being burnt during this update interval\",\"tokenSupply\":\"Total supply of pool tokens\"},\"returns\":{\"_0\":\"Number of settlement tokens to be withdrawn on a burn\"}},\"isBeforeFrontRunningInterval(uint256,uint256,uint256,uint256)\":{\"params\":{\"frontRunningInterval\":\"The window of time before a price update in which users can have their commit executed from\",\"lastPriceTimestamp\":\"The timestamp of the last price update\",\"subjectTime\":\"The timestamp for which you want to calculate if it was beforeFrontRunningInterval\",\"updateInterval\":\"The interval between price updates\"}},\"mintingOrBurningFee(bytes16,uint256)\":{\"params\":{\"amount\":\"The amount of settlement tokens being committed to mint\",\"feeRate\":\"PoolCommitter's mintingFee or burningFee - The amount that is extracted from each mint or burn. Given as the decimal * 10 ^ 18. For example, 60% fee is 0.6 * 10 ^ 18 Fees can be 0.\"}},\"mulFraction(uint256,uint256,uint256)\":{\"params\":{\"denominator\":\"The denominator of the fraction being multipled with `number`\",\"number\":\"The number with which the fraction calculated from `numerator` and `denominator` will be multiplied\",\"numerator\":\"The numerator of the fraction being multipled with `number`\"},\"returns\":{\"_0\":\"The result of multiplying number with numerator/denominator, as an integer\"}},\"multiplyBytes(bytes16,bytes16)\":{\"params\":{\"x\":\"The number to be multiplied by `y`\",\"y\":\"The number to be multiplied by `x`\"}},\"multiplyDecimalByUInt(bytes16,uint256)\":{\"params\":{\"a\":\"The first term\",\"b\":\"The second term\"},\"returns\":{\"_0\":\"The product of a*b as a decimal\"}},\"processBurnInstantMintCommit(uint256,bytes16,bytes16,bytes16)\":{\"details\":\"Takes out the burn fee before taking out the mint fee.\",\"params\":{\"amount\":\"The amount of pool tokens being flipped\",\"burnPrice\":\"The price of the pool token being burnt\",\"burningFee\":\"Fee rate for pool token burns\",\"mintingFee\":\"Fee rate for mints\"},\"returns\":{\"_0\":\"Amount of settlement tokens used to mint.\",\"_1\":\"The burn fee. This should be given to the side of the pool of the burnt tokens.\",\"_2\":\"The mint fee. This should be given to the side of the pool that is being minted into.\"}},\"subtractBytes(bytes16,bytes16)\":{\"params\":{\"x\":\"The number to be subtracted by `y`\",\"y\":\"The number to subtract from `x`\"}}},\"title\":\"Library for various useful (mostly) mathematical functions\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"MAX_DECIMALS()\":{\"notice\":\"Maximum number of decimal places supported by this contract (ABDKMathQuad defines this but it's private)\"},\"ONE()\":{\"notice\":\"ABDKMathQuad-formatted representation of the number one\"},\"WAD_PRECISION()\":{\"notice\":\"Maximum precision supportable via wad arithmetic (for this contract)\"},\"addBytes(bytes16,bytes16)\":{\"notice\":\"Performs an addition on two bytes16 numbers\"},\"appropriateUpdateIntervalId(uint256,uint256,uint256,uint256,uint256)\":{\"notice\":\"Calculates the update interval ID that a commitment should be placed in.\"},\"calculateValueTransfer(uint256,uint256,bytes16,int256,int256,bytes16)\":{\"notice\":\"Calculates the effect of a price change. This involves calculating how many funds to transfer from the losing pool to the other.\"},\"compareDecimals(bytes16,bytes16)\":{\"notice\":\"Compares two decimal numbers\"},\"convertDecimalToUInt(bytes16)\":{\"notice\":\"Converts a raw decimal value to a more readable uint256 value\"},\"convertUIntToDecimal(uint256)\":{\"notice\":\"Converts an integer value to a compatible decimal value\"},\"divInt(int256,int256)\":{\"notice\":\"Divides two integers\"},\"fromWad(uint256,uint256)\":{\"notice\":\"Converts from a WAD to normal value\"},\"getBalancesAfterFees(uint256,uint256,uint256)\":{\"notice\":\"Gets the short and long balances after the keeper rewards have been paid out         Keeper rewards are paid proportionally to the short and long pool\"},\"getBurn(bytes16,uint256)\":{\"notice\":\"Calculate the number of settlement tokens to return, based on a price and an amount of pool tokens being burnt\"},\"getLossAmount(bytes16,uint256)\":{\"notice\":\"Calculates the amount to take from the losing pool\"},\"getLossMultiplier(bytes16,int8,bytes16)\":{\"notice\":\"Calculates the loss multiplier to apply to the losing pool. Includes the power leverage\"},\"getMint(bytes16,uint256)\":{\"notice\":\"Calculates the number of pool tokens to mint, given some settlement token amount and a price\"},\"getMintAmount(uint256,uint256,uint256,uint256)\":{\"notice\":\"Gets the number of pool tokens to be minted based on existing tokens\"},\"getPrice(uint256,uint256)\":{\"notice\":\"Get the Settlement/PoolToken price, in ABDK IEE754 precision\"},\"getRatio(uint256,uint256)\":{\"notice\":\"Calculates the ratio between two numbers\"},\"getUpdatedAggregateBalance(PoolSwapLibrary.UpdateData)\":{\"notice\":\"Calculate the change in a user's balance based on recent commit(s)\"},\"getWithdrawAmountOnBurn(uint256,uint256,uint256,uint256)\":{\"notice\":\"Gets the number of settlement tokens to be withdrawn based on a pool token burn amount\"},\"isBeforeFrontRunningInterval(uint256,uint256,uint256,uint256)\":{\"notice\":\"Returns true if the given timestamp is BEFORE the frontRunningInterval starts\"},\"mintingOrBurningFee(bytes16,uint256)\":{\"notice\":\"Calculate the amount of settlement tokens to take as the minting fee\"},\"mulFraction(uint256,uint256,uint256)\":{\"notice\":\"Multiply an integer by a fractionnumber * numerator / denominator\"},\"multiplyBytes(bytes16,bytes16)\":{\"notice\":\"Multiplies two numbers\"},\"multiplyDecimalByUInt(bytes16,uint256)\":{\"notice\":\"Multiplies a decimal and an unsigned integer\"},\"processBurnInstantMintCommit(uint256,bytes16,bytes16,bytes16)\":{\"notice\":\"Given an amount of pool tokens to flip to the other side of the pool, calculate the amount of settlement tokens generated from the burn, burn fee, and subsequent minting fee\"},\"subtractBytes(bytes16,bytes16)\":{\"notice\":\"Performs a subtraction on two bytes16 numbers\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/libraries/PoolSwapLibrary.sol\":\"PoolSwapLibrary\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"abdk-libraries-solidity/ABDKMathQuad.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-4-Clause\\n/*\\n * ABDK Math Quad Smart Contract Library.  Copyright \\u00a9 2019 by ABDK Consulting.\\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\\n */\\npragma solidity ^0.8.0;\\n\\n/**\\n * Smart contract library of mathematical functions operating with IEEE 754\\n * quadruple-precision binary floating-point numbers (quadruple precision\\n * numbers).  As long as quadruple precision numbers are 16-bytes long, they are\\n * represented by bytes16 type.\\n */\\nlibrary ABDKMathQuad {\\n  /*\\n   * 0.\\n   */\\n  bytes16 private constant POSITIVE_ZERO = 0x00000000000000000000000000000000;\\n\\n  /*\\n   * -0.\\n   */\\n  bytes16 private constant NEGATIVE_ZERO = 0x80000000000000000000000000000000;\\n\\n  /*\\n   * +Infinity.\\n   */\\n  bytes16 private constant POSITIVE_INFINITY = 0x7FFF0000000000000000000000000000;\\n\\n  /*\\n   * -Infinity.\\n   */\\n  bytes16 private constant NEGATIVE_INFINITY = 0xFFFF0000000000000000000000000000;\\n\\n  /*\\n   * Canonical NaN value.\\n   */\\n  bytes16 private constant NaN = 0x7FFF8000000000000000000000000000;\\n\\n  /**\\n   * Convert signed 256-bit integer number into quadruple precision number.\\n   *\\n   * @param x signed 256-bit integer number\\n   * @return quadruple precision number\\n   */\\n  function fromInt (int256 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (x == 0) return bytes16 (0);\\n      else {\\n        // We rely on overflow behavior here\\n        uint256 result = uint256 (x > 0 ? x : -x);\\n\\n        uint256 msb = mostSignificantBit (result);\\n        if (msb < 112) result <<= 112 - msb;\\n        else if (msb > 112) result >>= msb - 112;\\n\\n        result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16383 + msb << 112;\\n        if (x < 0) result |= 0x80000000000000000000000000000000;\\n\\n        return bytes16 (uint128 (result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into signed 256-bit integer number\\n   * rounding towards zero.  Revert on overflow.\\n   *\\n   * @param x quadruple precision number\\n   * @return signed 256-bit integer number\\n   */\\n  function toInt (bytes16 x) internal pure returns (int256) {\\n    unchecked {\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n\\n      require (exponent <= 16638); // Overflow\\n      if (exponent < 16383) return 0; // Underflow\\n\\n      uint256 result = uint256 (uint128 (x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF |\\n        0x10000000000000000000000000000;\\n\\n      if (exponent < 16495) result >>= 16495 - exponent;\\n      else if (exponent > 16495) result <<= exponent - 16495;\\n\\n      if (uint128 (x) >= 0x80000000000000000000000000000000) { // Negative\\n        require (result <= 0x8000000000000000000000000000000000000000000000000000000000000000);\\n        return -int256 (result); // We rely on overflow behavior here\\n      } else {\\n        require (result <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n        return int256 (result);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert unsigned 256-bit integer number into quadruple precision number.\\n   *\\n   * @param x unsigned 256-bit integer number\\n   * @return quadruple precision number\\n   */\\n  function fromUInt (uint256 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (x == 0) return bytes16 (0);\\n      else {\\n        uint256 result = x;\\n\\n        uint256 msb = mostSignificantBit (result);\\n        if (msb < 112) result <<= 112 - msb;\\n        else if (msb > 112) result >>= msb - 112;\\n\\n        result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16383 + msb << 112;\\n\\n        return bytes16 (uint128 (result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into unsigned 256-bit integer number\\n   * rounding towards zero.  Revert on underflow.  Note, that negative floating\\n   * point numbers in range (-1.0 .. 0.0) may be converted to unsigned integer\\n   * without error, because they are rounded to zero.\\n   *\\n   * @param x quadruple precision number\\n   * @return unsigned 256-bit integer number\\n   */\\n  function toUInt (bytes16 x) internal pure returns (uint256) {\\n    unchecked {\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n\\n      if (exponent < 16383) return 0; // Underflow\\n\\n      require (uint128 (x) < 0x80000000000000000000000000000000); // Negative\\n\\n      require (exponent <= 16638); // Overflow\\n      uint256 result = uint256 (uint128 (x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF |\\n        0x10000000000000000000000000000;\\n\\n      if (exponent < 16495) result >>= 16495 - exponent;\\n      else if (exponent > 16495) result <<= exponent - 16495;\\n\\n      return result;\\n    }\\n  }\\n\\n  /**\\n   * Convert signed 128.128 bit fixed point number into quadruple precision\\n   * number.\\n   *\\n   * @param x signed 128.128 bit fixed point number\\n   * @return quadruple precision number\\n   */\\n  function from128x128 (int256 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (x == 0) return bytes16 (0);\\n      else {\\n        // We rely on overflow behavior here\\n        uint256 result = uint256 (x > 0 ? x : -x);\\n\\n        uint256 msb = mostSignificantBit (result);\\n        if (msb < 112) result <<= 112 - msb;\\n        else if (msb > 112) result >>= msb - 112;\\n\\n        result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16255 + msb << 112;\\n        if (x < 0) result |= 0x80000000000000000000000000000000;\\n\\n        return bytes16 (uint128 (result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into signed 128.128 bit fixed point\\n   * number.  Revert on overflow.\\n   *\\n   * @param x quadruple precision number\\n   * @return signed 128.128 bit fixed point number\\n   */\\n  function to128x128 (bytes16 x) internal pure returns (int256) {\\n    unchecked {\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n\\n      require (exponent <= 16510); // Overflow\\n      if (exponent < 16255) return 0; // Underflow\\n\\n      uint256 result = uint256 (uint128 (x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF |\\n        0x10000000000000000000000000000;\\n\\n      if (exponent < 16367) result >>= 16367 - exponent;\\n      else if (exponent > 16367) result <<= exponent - 16367;\\n\\n      if (uint128 (x) >= 0x80000000000000000000000000000000) { // Negative\\n        require (result <= 0x8000000000000000000000000000000000000000000000000000000000000000);\\n        return -int256 (result); // We rely on overflow behavior here\\n      } else {\\n        require (result <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n        return int256 (result);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert signed 64.64 bit fixed point number into quadruple precision\\n   * number.\\n   *\\n   * @param x signed 64.64 bit fixed point number\\n   * @return quadruple precision number\\n   */\\n  function from64x64 (int128 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (x == 0) return bytes16 (0);\\n      else {\\n        // We rely on overflow behavior here\\n        uint256 result = uint128 (x > 0 ? x : -x);\\n\\n        uint256 msb = mostSignificantBit (result);\\n        if (msb < 112) result <<= 112 - msb;\\n        else if (msb > 112) result >>= msb - 112;\\n\\n        result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16319 + msb << 112;\\n        if (x < 0) result |= 0x80000000000000000000000000000000;\\n\\n        return bytes16 (uint128 (result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into signed 64.64 bit fixed point\\n   * number.  Revert on overflow.\\n   *\\n   * @param x quadruple precision number\\n   * @return signed 64.64 bit fixed point number\\n   */\\n  function to64x64 (bytes16 x) internal pure returns (int128) {\\n    unchecked {\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n\\n      require (exponent <= 16446); // Overflow\\n      if (exponent < 16319) return 0; // Underflow\\n\\n      uint256 result = uint256 (uint128 (x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF |\\n        0x10000000000000000000000000000;\\n\\n      if (exponent < 16431) result >>= 16431 - exponent;\\n      else if (exponent > 16431) result <<= exponent - 16431;\\n\\n      if (uint128 (x) >= 0x80000000000000000000000000000000) { // Negative\\n        require (result <= 0x80000000000000000000000000000000);\\n        return -int128 (int256 (result)); // We rely on overflow behavior here\\n      } else {\\n        require (result <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n        return int128 (int256 (result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert octuple precision number into quadruple precision number.\\n   *\\n   * @param x octuple precision number\\n   * @return quadruple precision number\\n   */\\n  function fromOctuple (bytes32 x) internal pure returns (bytes16) {\\n    unchecked {\\n      bool negative = x & 0x8000000000000000000000000000000000000000000000000000000000000000 > 0;\\n\\n      uint256 exponent = uint256 (x) >> 236 & 0x7FFFF;\\n      uint256 significand = uint256 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      if (exponent == 0x7FFFF) {\\n        if (significand > 0) return NaN;\\n        else return negative ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\n      }\\n\\n      if (exponent > 278526)\\n        return negative ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\n      else if (exponent < 245649)\\n        return negative ? NEGATIVE_ZERO : POSITIVE_ZERO;\\n      else if (exponent < 245761) {\\n        significand = (significand | 0x100000000000000000000000000000000000000000000000000000000000) >> 245885 - exponent;\\n        exponent = 0;\\n      } else {\\n        significand >>= 124;\\n        exponent -= 245760;\\n      }\\n\\n      uint128 result = uint128 (significand | exponent << 112);\\n      if (negative) result |= 0x80000000000000000000000000000000;\\n\\n      return bytes16 (result);\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into octuple precision number.\\n   *\\n   * @param x quadruple precision number\\n   * @return octuple precision number\\n   */\\n  function toOctuple (bytes16 x) internal pure returns (bytes32) {\\n    unchecked {\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n\\n      uint256 result = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      if (exponent == 0x7FFF) exponent = 0x7FFFF; // Infinity or NaN\\n      else if (exponent == 0) {\\n        if (result > 0) {\\n          uint256 msb = mostSignificantBit (result);\\n          result = result << 236 - msb & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          exponent = 245649 + msb;\\n        }\\n      } else {\\n        result <<= 124;\\n        exponent += 245760;\\n      }\\n\\n      result |= exponent << 236;\\n      if (uint128 (x) >= 0x80000000000000000000000000000000)\\n        result |= 0x8000000000000000000000000000000000000000000000000000000000000000;\\n\\n      return bytes32 (result);\\n    }\\n  }\\n\\n  /**\\n   * Convert double precision number into quadruple precision number.\\n   *\\n   * @param x double precision number\\n   * @return quadruple precision number\\n   */\\n  function fromDouble (bytes8 x) internal pure returns (bytes16) {\\n    unchecked {\\n      uint256 exponent = uint64 (x) >> 52 & 0x7FF;\\n\\n      uint256 result = uint64 (x) & 0xFFFFFFFFFFFFF;\\n\\n      if (exponent == 0x7FF) exponent = 0x7FFF; // Infinity or NaN\\n      else if (exponent == 0) {\\n        if (result > 0) {\\n          uint256 msb = mostSignificantBit (result);\\n          result = result << 112 - msb & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          exponent = 15309 + msb;\\n        }\\n      } else {\\n        result <<= 60;\\n        exponent += 15360;\\n      }\\n\\n      result |= exponent << 112;\\n      if (x & 0x8000000000000000 > 0)\\n        result |= 0x80000000000000000000000000000000;\\n\\n      return bytes16 (uint128 (result));\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into double precision number.\\n   *\\n   * @param x quadruple precision number\\n   * @return double precision number\\n   */\\n  function toDouble (bytes16 x) internal pure returns (bytes8) {\\n    unchecked {\\n      bool negative = uint128 (x) >= 0x80000000000000000000000000000000;\\n\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n      uint256 significand = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      if (exponent == 0x7FFF) {\\n        if (significand > 0) return 0x7FF8000000000000; // NaN\\n        else return negative ?\\n            bytes8 (0xFFF0000000000000) : // -Infinity\\n            bytes8 (0x7FF0000000000000); // Infinity\\n      }\\n\\n      if (exponent > 17406)\\n        return negative ?\\n            bytes8 (0xFFF0000000000000) : // -Infinity\\n            bytes8 (0x7FF0000000000000); // Infinity\\n      else if (exponent < 15309)\\n        return negative ?\\n            bytes8 (0x8000000000000000) : // -0\\n            bytes8 (0x0000000000000000); // 0\\n      else if (exponent < 15361) {\\n        significand = (significand | 0x10000000000000000000000000000) >> 15421 - exponent;\\n        exponent = 0;\\n      } else {\\n        significand >>= 60;\\n        exponent -= 15360;\\n      }\\n\\n      uint64 result = uint64 (significand | exponent << 52);\\n      if (negative) result |= 0x8000000000000000;\\n\\n      return bytes8 (result);\\n    }\\n  }\\n\\n  /**\\n   * Test whether given quadruple precision number is NaN.\\n   *\\n   * @param x quadruple precision number\\n   * @return true if x is NaN, false otherwise\\n   */\\n  function isNaN (bytes16 x) internal pure returns (bool) {\\n    unchecked {\\n      return uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF >\\n        0x7FFF0000000000000000000000000000;\\n    }\\n  }\\n\\n  /**\\n   * Test whether given quadruple precision number is positive or negative\\n   * infinity.\\n   *\\n   * @param x quadruple precision number\\n   * @return true if x is positive or negative infinity, false otherwise\\n   */\\n  function isInfinity (bytes16 x) internal pure returns (bool) {\\n    unchecked {\\n      return uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF ==\\n        0x7FFF0000000000000000000000000000;\\n    }\\n  }\\n\\n  /**\\n   * Calculate sign of x, i.e. -1 if x is negative, 0 if x if zero, and 1 if x\\n   * is positive.  Note that sign (-0) is zero.  Revert if x is NaN. \\n   *\\n   * @param x quadruple precision number\\n   * @return sign of x\\n   */\\n  function sign (bytes16 x) internal pure returns (int8) {\\n    unchecked {\\n      uint128 absoluteX = uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      require (absoluteX <= 0x7FFF0000000000000000000000000000); // Not NaN\\n\\n      if (absoluteX == 0) return 0;\\n      else if (uint128 (x) >= 0x80000000000000000000000000000000) return -1;\\n      else return 1;\\n    }\\n  }\\n\\n  /**\\n   * Calculate sign (x - y).  Revert if either argument is NaN, or both\\n   * arguments are infinities of the same sign. \\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return sign (x - y)\\n   */\\n  function cmp (bytes16 x, bytes16 y) internal pure returns (int8) {\\n    unchecked {\\n      uint128 absoluteX = uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      require (absoluteX <= 0x7FFF0000000000000000000000000000); // Not NaN\\n\\n      uint128 absoluteY = uint128 (y) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      require (absoluteY <= 0x7FFF0000000000000000000000000000); // Not NaN\\n\\n      // Not infinities of the same sign\\n      require (x != y || absoluteX < 0x7FFF0000000000000000000000000000);\\n\\n      if (x == y) return 0;\\n      else {\\n        bool negativeX = uint128 (x) >= 0x80000000000000000000000000000000;\\n        bool negativeY = uint128 (y) >= 0x80000000000000000000000000000000;\\n\\n        if (negativeX) {\\n          if (negativeY) return absoluteX > absoluteY ? -1 : int8 (1);\\n          else return -1; \\n        } else {\\n          if (negativeY) return 1;\\n          else return absoluteX > absoluteY ? int8 (1) : -1;\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Test whether x equals y.  NaN, infinity, and -infinity are not equal to\\n   * anything. \\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return true if x equals to y, false otherwise\\n   */\\n  function eq (bytes16 x, bytes16 y) internal pure returns (bool) {\\n    unchecked {\\n      if (x == y) {\\n        return uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF <\\n          0x7FFF0000000000000000000000000000;\\n      } else return false;\\n    }\\n  }\\n\\n  /**\\n   * Calculate x + y.  Special values behave in the following way:\\n   *\\n   * NaN + x = NaN for any x.\\n   * Infinity + x = Infinity for any finite x.\\n   * -Infinity + x = -Infinity for any finite x.\\n   * Infinity + Infinity = Infinity.\\n   * -Infinity + -Infinity = -Infinity.\\n   * Infinity + -Infinity = -Infinity + Infinity = NaN.\\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function add (bytes16 x, bytes16 y) internal pure returns (bytes16) {\\n    unchecked {\\n      uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n      uint256 yExponent = uint128 (y) >> 112 & 0x7FFF;\\n\\n      if (xExponent == 0x7FFF) {\\n        if (yExponent == 0x7FFF) { \\n          if (x == y) return x;\\n          else return NaN;\\n        } else return x; \\n      } else if (yExponent == 0x7FFF) return y;\\n      else {\\n        bool xSign = uint128 (x) >= 0x80000000000000000000000000000000;\\n        uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (xExponent == 0) xExponent = 1;\\n        else xSignifier |= 0x10000000000000000000000000000;\\n\\n        bool ySign = uint128 (y) >= 0x80000000000000000000000000000000;\\n        uint256 ySignifier = uint128 (y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (yExponent == 0) yExponent = 1;\\n        else ySignifier |= 0x10000000000000000000000000000;\\n\\n        if (xSignifier == 0) return y == NEGATIVE_ZERO ? POSITIVE_ZERO : y;\\n        else if (ySignifier == 0) return x == NEGATIVE_ZERO ? POSITIVE_ZERO : x;\\n        else {\\n          int256 delta = int256 (xExponent) - int256 (yExponent);\\n  \\n          if (xSign == ySign) {\\n            if (delta > 112) return x;\\n            else if (delta > 0) ySignifier >>= uint256 (delta);\\n            else if (delta < -112) return y;\\n            else if (delta < 0) {\\n              xSignifier >>= uint256 (-delta);\\n              xExponent = yExponent;\\n            }\\n  \\n            xSignifier += ySignifier;\\n  \\n            if (xSignifier >= 0x20000000000000000000000000000) {\\n              xSignifier >>= 1;\\n              xExponent += 1;\\n            }\\n  \\n            if (xExponent == 0x7FFF)\\n              return xSign ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\n            else {\\n              if (xSignifier < 0x10000000000000000000000000000) xExponent = 0;\\n              else xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n  \\n              return bytes16 (uint128 (\\n                  (xSign ? 0x80000000000000000000000000000000 : 0) |\\n                  (xExponent << 112) |\\n                  xSignifier)); \\n            }\\n          } else {\\n            if (delta > 0) {\\n              xSignifier <<= 1;\\n              xExponent -= 1;\\n            } else if (delta < 0) {\\n              ySignifier <<= 1;\\n              xExponent = yExponent - 1;\\n            }\\n\\n            if (delta > 112) ySignifier = 1;\\n            else if (delta > 1) ySignifier = (ySignifier - 1 >> uint256 (delta - 1)) + 1;\\n            else if (delta < -112) xSignifier = 1;\\n            else if (delta < -1) xSignifier = (xSignifier - 1 >> uint256 (-delta - 1)) + 1;\\n\\n            if (xSignifier >= ySignifier) xSignifier -= ySignifier;\\n            else {\\n              xSignifier = ySignifier - xSignifier;\\n              xSign = ySign;\\n            }\\n\\n            if (xSignifier == 0)\\n              return POSITIVE_ZERO;\\n\\n            uint256 msb = mostSignificantBit (xSignifier);\\n\\n            if (msb == 113) {\\n              xSignifier = xSignifier >> 1 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n              xExponent += 1;\\n            } else if (msb < 112) {\\n              uint256 shift = 112 - msb;\\n              if (xExponent > shift) {\\n                xSignifier = xSignifier << shift & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n                xExponent -= shift;\\n              } else {\\n                xSignifier <<= xExponent - 1;\\n                xExponent = 0;\\n              }\\n            } else xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n            if (xExponent == 0x7FFF)\\n              return xSign ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\n            else return bytes16 (uint128 (\\n                (xSign ? 0x80000000000000000000000000000000 : 0) |\\n                (xExponent << 112) |\\n                xSignifier));\\n          }\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate x - y.  Special values behave in the following way:\\n   *\\n   * NaN - x = NaN for any x.\\n   * Infinity - x = Infinity for any finite x.\\n   * -Infinity - x = -Infinity for any finite x.\\n   * Infinity - -Infinity = Infinity.\\n   * -Infinity - Infinity = -Infinity.\\n   * Infinity - Infinity = -Infinity - -Infinity = NaN.\\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function sub (bytes16 x, bytes16 y) internal pure returns (bytes16) {\\n    unchecked {\\n      return add (x, y ^ 0x80000000000000000000000000000000);\\n    }\\n  }\\n\\n  /**\\n   * Calculate x * y.  Special values behave in the following way:\\n   *\\n   * NaN * x = NaN for any x.\\n   * Infinity * x = Infinity for any finite positive x.\\n   * Infinity * x = -Infinity for any finite negative x.\\n   * -Infinity * x = -Infinity for any finite positive x.\\n   * -Infinity * x = Infinity for any finite negative x.\\n   * Infinity * 0 = NaN.\\n   * -Infinity * 0 = NaN.\\n   * Infinity * Infinity = Infinity.\\n   * Infinity * -Infinity = -Infinity.\\n   * -Infinity * Infinity = -Infinity.\\n   * -Infinity * -Infinity = Infinity.\\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function mul (bytes16 x, bytes16 y) internal pure returns (bytes16) {\\n    unchecked {\\n      uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n      uint256 yExponent = uint128 (y) >> 112 & 0x7FFF;\\n\\n      if (xExponent == 0x7FFF) {\\n        if (yExponent == 0x7FFF) {\\n          if (x == y) return x ^ y & 0x80000000000000000000000000000000;\\n          else if (x ^ y == 0x80000000000000000000000000000000) return x | y;\\n          else return NaN;\\n        } else {\\n          if (y & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\\n          else return x ^ y & 0x80000000000000000000000000000000;\\n        }\\n      } else if (yExponent == 0x7FFF) {\\n          if (x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\\n          else return y ^ x & 0x80000000000000000000000000000000;\\n      } else {\\n        uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (xExponent == 0) xExponent = 1;\\n        else xSignifier |= 0x10000000000000000000000000000;\\n\\n        uint256 ySignifier = uint128 (y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (yExponent == 0) yExponent = 1;\\n        else ySignifier |= 0x10000000000000000000000000000;\\n\\n        xSignifier *= ySignifier;\\n        if (xSignifier == 0)\\n          return (x ^ y) & 0x80000000000000000000000000000000 > 0 ?\\n              NEGATIVE_ZERO : POSITIVE_ZERO;\\n\\n        xExponent += yExponent;\\n\\n        uint256 msb =\\n          xSignifier >= 0x200000000000000000000000000000000000000000000000000000000 ? 225 :\\n          xSignifier >= 0x100000000000000000000000000000000000000000000000000000000 ? 224 :\\n          mostSignificantBit (xSignifier);\\n\\n        if (xExponent + msb < 16496) { // Underflow\\n          xExponent = 0;\\n          xSignifier = 0;\\n        } else if (xExponent + msb < 16608) { // Subnormal\\n          if (xExponent < 16496)\\n            xSignifier >>= 16496 - xExponent;\\n          else if (xExponent > 16496)\\n            xSignifier <<= xExponent - 16496;\\n          xExponent = 0;\\n        } else if (xExponent + msb > 49373) {\\n          xExponent = 0x7FFF;\\n          xSignifier = 0;\\n        } else {\\n          if (msb > 112)\\n            xSignifier >>= msb - 112;\\n          else if (msb < 112)\\n            xSignifier <<= 112 - msb;\\n\\n          xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n          xExponent = xExponent + msb - 16607;\\n        }\\n\\n        return bytes16 (uint128 (uint128 ((x ^ y) & 0x80000000000000000000000000000000) |\\n            xExponent << 112 | xSignifier));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate x / y.  Special values behave in the following way:\\n   *\\n   * NaN / x = NaN for any x.\\n   * x / NaN = NaN for any x.\\n   * Infinity / x = Infinity for any finite non-negative x.\\n   * Infinity / x = -Infinity for any finite negative x including -0.\\n   * -Infinity / x = -Infinity for any finite non-negative x.\\n   * -Infinity / x = Infinity for any finite negative x including -0.\\n   * x / Infinity = 0 for any finite non-negative x.\\n   * x / -Infinity = -0 for any finite non-negative x.\\n   * x / Infinity = -0 for any finite non-negative x including -0.\\n   * x / -Infinity = 0 for any finite non-negative x including -0.\\n   * \\n   * Infinity / Infinity = NaN.\\n   * Infinity / -Infinity = -NaN.\\n   * -Infinity / Infinity = -NaN.\\n   * -Infinity / -Infinity = NaN.\\n   *\\n   * Division by zero behaves in the following way:\\n   *\\n   * x / 0 = Infinity for any finite positive x.\\n   * x / -0 = -Infinity for any finite positive x.\\n   * x / 0 = -Infinity for any finite negative x.\\n   * x / -0 = Infinity for any finite negative x.\\n   * 0 / 0 = NaN.\\n   * 0 / -0 = NaN.\\n   * -0 / 0 = NaN.\\n   * -0 / -0 = NaN.\\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function div (bytes16 x, bytes16 y) internal pure returns (bytes16) {\\n    unchecked {\\n      uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n      uint256 yExponent = uint128 (y) >> 112 & 0x7FFF;\\n\\n      if (xExponent == 0x7FFF) {\\n        if (yExponent == 0x7FFF) return NaN;\\n        else return x ^ y & 0x80000000000000000000000000000000;\\n      } else if (yExponent == 0x7FFF) {\\n        if (y & 0x0000FFFFFFFFFFFFFFFFFFFFFFFFFFFF != 0) return NaN;\\n        else return POSITIVE_ZERO | (x ^ y) & 0x80000000000000000000000000000000;\\n      } else if (y & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) {\\n        if (x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\\n        else return POSITIVE_INFINITY | (x ^ y) & 0x80000000000000000000000000000000;\\n      } else {\\n        uint256 ySignifier = uint128 (y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (yExponent == 0) yExponent = 1;\\n        else ySignifier |= 0x10000000000000000000000000000;\\n\\n        uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (xExponent == 0) {\\n          if (xSignifier != 0) {\\n            uint shift = 226 - mostSignificantBit (xSignifier);\\n\\n            xSignifier <<= shift;\\n\\n            xExponent = 1;\\n            yExponent += shift - 114;\\n          }\\n        }\\n        else {\\n          xSignifier = (xSignifier | 0x10000000000000000000000000000) << 114;\\n        }\\n\\n        xSignifier = xSignifier / ySignifier;\\n        if (xSignifier == 0)\\n          return (x ^ y) & 0x80000000000000000000000000000000 > 0 ?\\n              NEGATIVE_ZERO : POSITIVE_ZERO;\\n\\n        assert (xSignifier >= 0x1000000000000000000000000000);\\n\\n        uint256 msb =\\n          xSignifier >= 0x80000000000000000000000000000 ? mostSignificantBit (xSignifier) :\\n          xSignifier >= 0x40000000000000000000000000000 ? 114 :\\n          xSignifier >= 0x20000000000000000000000000000 ? 113 : 112;\\n\\n        if (xExponent + msb > yExponent + 16497) { // Overflow\\n          xExponent = 0x7FFF;\\n          xSignifier = 0;\\n        } else if (xExponent + msb + 16380  < yExponent) { // Underflow\\n          xExponent = 0;\\n          xSignifier = 0;\\n        } else if (xExponent + msb + 16268  < yExponent) { // Subnormal\\n          if (xExponent + 16380 > yExponent)\\n            xSignifier <<= xExponent + 16380 - yExponent;\\n          else if (xExponent + 16380 < yExponent)\\n            xSignifier >>= yExponent - xExponent - 16380;\\n\\n          xExponent = 0;\\n        } else { // Normal\\n          if (msb > 112)\\n            xSignifier >>= msb - 112;\\n\\n          xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n          xExponent = xExponent + msb + 16269 - yExponent;\\n        }\\n\\n        return bytes16 (uint128 (uint128 ((x ^ y) & 0x80000000000000000000000000000000) |\\n            xExponent << 112 | xSignifier));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate -x.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function neg (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      return x ^ 0x80000000000000000000000000000000;\\n    }\\n  }\\n\\n  /**\\n   * Calculate |x|.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function abs (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      return x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n    }\\n  }\\n\\n  /**\\n   * Calculate square root of x.  Return NaN on negative x excluding -0.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function sqrt (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (uint128 (x) >  0x80000000000000000000000000000000) return NaN;\\n      else {\\n        uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n        if (xExponent == 0x7FFF) return x;\\n        else {\\n          uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          if (xExponent == 0) xExponent = 1;\\n          else xSignifier |= 0x10000000000000000000000000000;\\n\\n          if (xSignifier == 0) return POSITIVE_ZERO;\\n\\n          bool oddExponent = xExponent & 0x1 == 0;\\n          xExponent = xExponent + 16383 >> 1;\\n\\n          if (oddExponent) {\\n            if (xSignifier >= 0x10000000000000000000000000000)\\n              xSignifier <<= 113;\\n            else {\\n              uint256 msb = mostSignificantBit (xSignifier);\\n              uint256 shift = (226 - msb) & 0xFE;\\n              xSignifier <<= shift;\\n              xExponent -= shift - 112 >> 1;\\n            }\\n          } else {\\n            if (xSignifier >= 0x10000000000000000000000000000)\\n              xSignifier <<= 112;\\n            else {\\n              uint256 msb = mostSignificantBit (xSignifier);\\n              uint256 shift = (225 - msb) & 0xFE;\\n              xSignifier <<= shift;\\n              xExponent -= shift - 112 >> 1;\\n            }\\n          }\\n\\n          uint256 r = 0x10000000000000000000000000000;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1; // Seven iterations should be enough\\n          uint256 r1 = xSignifier / r;\\n          if (r1 < r) r = r1;\\n\\n          return bytes16 (uint128 (xExponent << 112 | r & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF));\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate binary logarithm of x.  Return NaN on negative x excluding -0.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function log_2 (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (uint128 (x) > 0x80000000000000000000000000000000) return NaN;\\n      else if (x == 0x3FFF0000000000000000000000000000) return POSITIVE_ZERO; \\n      else {\\n        uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n        if (xExponent == 0x7FFF) return x;\\n        else {\\n          uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          if (xExponent == 0) xExponent = 1;\\n          else xSignifier |= 0x10000000000000000000000000000;\\n\\n          if (xSignifier == 0) return NEGATIVE_INFINITY;\\n\\n          bool resultNegative;\\n          uint256 resultExponent = 16495;\\n          uint256 resultSignifier;\\n\\n          if (xExponent >= 0x3FFF) {\\n            resultNegative = false;\\n            resultSignifier = xExponent - 0x3FFF;\\n            xSignifier <<= 15;\\n          } else {\\n            resultNegative = true;\\n            if (xSignifier >= 0x10000000000000000000000000000) {\\n              resultSignifier = 0x3FFE - xExponent;\\n              xSignifier <<= 15;\\n            } else {\\n              uint256 msb = mostSignificantBit (xSignifier);\\n              resultSignifier = 16493 - msb;\\n              xSignifier <<= 127 - msb;\\n            }\\n          }\\n\\n          if (xSignifier == 0x80000000000000000000000000000000) {\\n            if (resultNegative) resultSignifier += 1;\\n            uint256 shift = 112 - mostSignificantBit (resultSignifier);\\n            resultSignifier <<= shift;\\n            resultExponent -= shift;\\n          } else {\\n            uint256 bb = resultNegative ? 1 : 0;\\n            while (resultSignifier < 0x10000000000000000000000000000) {\\n              resultSignifier <<= 1;\\n              resultExponent -= 1;\\n  \\n              xSignifier *= xSignifier;\\n              uint256 b = xSignifier >> 255;\\n              resultSignifier += b ^ bb;\\n              xSignifier >>= 127 + b;\\n            }\\n          }\\n\\n          return bytes16 (uint128 ((resultNegative ? 0x80000000000000000000000000000000 : 0) |\\n              resultExponent << 112 | resultSignifier & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF));\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate natural logarithm of x.  Return NaN on negative x excluding -0.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function ln (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      return mul (log_2 (x), 0x3FFE62E42FEFA39EF35793C7673007E5);\\n    }\\n  }\\n\\n  /**\\n   * Calculate 2^x.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function pow_2 (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      bool xNegative = uint128 (x) > 0x80000000000000000000000000000000;\\n      uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n      uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      if (xExponent == 0x7FFF && xSignifier != 0) return NaN;\\n      else if (xExponent > 16397)\\n        return xNegative ? POSITIVE_ZERO : POSITIVE_INFINITY;\\n      else if (xExponent < 16255)\\n        return 0x3FFF0000000000000000000000000000;\\n      else {\\n        if (xExponent == 0) xExponent = 1;\\n        else xSignifier |= 0x10000000000000000000000000000;\\n\\n        if (xExponent > 16367)\\n          xSignifier <<= xExponent - 16367;\\n        else if (xExponent < 16367)\\n          xSignifier >>= 16367 - xExponent;\\n\\n        if (xNegative && xSignifier > 0x406E00000000000000000000000000000000)\\n          return POSITIVE_ZERO;\\n\\n        if (!xNegative && xSignifier > 0x3FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\n          return POSITIVE_INFINITY;\\n\\n        uint256 resultExponent = xSignifier >> 128;\\n        xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (xNegative && xSignifier != 0) {\\n          xSignifier = ~xSignifier;\\n          resultExponent += 1;\\n        }\\n\\n        uint256 resultSignifier = 0x80000000000000000000000000000000;\\n        if (xSignifier & 0x80000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x16A09E667F3BCC908B2FB1366EA957D3E >> 128;\\n        if (xSignifier & 0x40000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1306FE0A31B7152DE8D5A46305C85EDEC >> 128;\\n        if (xSignifier & 0x20000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1172B83C7D517ADCDF7C8C50EB14A791F >> 128;\\n        if (xSignifier & 0x10000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10B5586CF9890F6298B92B71842A98363 >> 128;\\n        if (xSignifier & 0x8000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1059B0D31585743AE7C548EB68CA417FD >> 128;\\n        if (xSignifier & 0x4000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x102C9A3E778060EE6F7CACA4F7A29BDE8 >> 128;\\n        if (xSignifier & 0x2000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10163DA9FB33356D84A66AE336DCDFA3F >> 128;\\n        if (xSignifier & 0x1000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100B1AFA5ABCBED6129AB13EC11DC9543 >> 128;\\n        if (xSignifier & 0x800000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10058C86DA1C09EA1FF19D294CF2F679B >> 128;\\n        if (xSignifier & 0x400000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1002C605E2E8CEC506D21BFC89A23A00F >> 128;\\n        if (xSignifier & 0x200000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100162F3904051FA128BCA9C55C31E5DF >> 128;\\n        if (xSignifier & 0x100000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000B175EFFDC76BA38E31671CA939725 >> 128;\\n        if (xSignifier & 0x80000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100058BA01FB9F96D6CACD4B180917C3D >> 128;\\n        if (xSignifier & 0x40000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10002C5CC37DA9491D0985C348C68E7B3 >> 128;\\n        if (xSignifier & 0x20000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000162E525EE054754457D5995292026 >> 128;\\n        if (xSignifier & 0x10000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000B17255775C040618BF4A4ADE83FC >> 128;\\n        if (xSignifier & 0x8000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB >> 128;\\n        if (xSignifier & 0x4000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 >> 128;\\n        if (xSignifier & 0x2000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000162E43F4F831060E02D839A9D16D >> 128;\\n        if (xSignifier & 0x1000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000B1721BCFC99D9F890EA06911763 >> 128;\\n        if (xSignifier & 0x800000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000058B90CF1E6D97F9CA14DBCC1628 >> 128;\\n        if (xSignifier & 0x400000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000002C5C863B73F016468F6BAC5CA2B >> 128;\\n        if (xSignifier & 0x200000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000162E430E5A18F6119E3C02282A5 >> 128;\\n        if (xSignifier & 0x100000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000B1721835514B86E6D96EFD1BFE >> 128;\\n        if (xSignifier & 0x80000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000058B90C0B48C6BE5DF846C5B2EF >> 128;\\n        if (xSignifier & 0x40000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000002C5C8601CC6B9E94213C72737A >> 128;\\n        if (xSignifier & 0x20000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000162E42FFF037DF38AA2B219F06 >> 128;\\n        if (xSignifier & 0x10000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000B17217FBA9C739AA5819F44F9 >> 128;\\n        if (xSignifier & 0x8000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000058B90BFCDEE5ACD3C1CEDC823 >> 128;\\n        if (xSignifier & 0x4000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000002C5C85FE31F35A6A30DA1BE50 >> 128;\\n        if (xSignifier & 0x2000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000162E42FF0999CE3541B9FFFCF >> 128;\\n        if (xSignifier & 0x1000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000B17217F80F4EF5AADDA45554 >> 128;\\n        if (xSignifier & 0x800000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000058B90BFBF8479BD5A81B51AD >> 128;\\n        if (xSignifier & 0x400000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000002C5C85FDF84BD62AE30A74CC >> 128;\\n        if (xSignifier & 0x200000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000162E42FEFB2FED257559BDAA >> 128;\\n        if (xSignifier & 0x100000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000B17217F7D5A7716BBA4A9AE >> 128;\\n        if (xSignifier & 0x80000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000058B90BFBE9DDBAC5E109CCE >> 128;\\n        if (xSignifier & 0x40000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000002C5C85FDF4B15DE6F17EB0D >> 128;\\n        if (xSignifier & 0x20000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000162E42FEFA494F1478FDE05 >> 128;\\n        if (xSignifier & 0x10000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000B17217F7D20CF927C8E94C >> 128;\\n        if (xSignifier & 0x8000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000058B90BFBE8F71CB4E4B33D >> 128;\\n        if (xSignifier & 0x4000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000002C5C85FDF477B662B26945 >> 128;\\n        if (xSignifier & 0x2000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000162E42FEFA3AE53369388C >> 128;\\n        if (xSignifier & 0x1000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000B17217F7D1D351A389D40 >> 128;\\n        if (xSignifier & 0x800000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000058B90BFBE8E8B2D3D4EDE >> 128;\\n        if (xSignifier & 0x400000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000002C5C85FDF4741BEA6E77E >> 128;\\n        if (xSignifier & 0x200000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000162E42FEFA39FE95583C2 >> 128;\\n        if (xSignifier & 0x100000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000B17217F7D1CFB72B45E1 >> 128;\\n        if (xSignifier & 0x80000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000058B90BFBE8E7CC35C3F0 >> 128;\\n        if (xSignifier & 0x40000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000002C5C85FDF473E242EA38 >> 128;\\n        if (xSignifier & 0x20000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000162E42FEFA39F02B772C >> 128;\\n        if (xSignifier & 0x10000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000B17217F7D1CF7D83C1A >> 128;\\n        if (xSignifier & 0x8000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000058B90BFBE8E7BDCBE2E >> 128;\\n        if (xSignifier & 0x4000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000002C5C85FDF473DEA871F >> 128;\\n        if (xSignifier & 0x2000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000162E42FEFA39EF44D91 >> 128;\\n        if (xSignifier & 0x1000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000B17217F7D1CF79E949 >> 128;\\n        if (xSignifier & 0x800000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000058B90BFBE8E7BCE544 >> 128;\\n        if (xSignifier & 0x400000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000002C5C85FDF473DE6ECA >> 128;\\n        if (xSignifier & 0x200000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000162E42FEFA39EF366F >> 128;\\n        if (xSignifier & 0x100000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000B17217F7D1CF79AFA >> 128;\\n        if (xSignifier & 0x80000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000058B90BFBE8E7BCD6D >> 128;\\n        if (xSignifier & 0x40000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000002C5C85FDF473DE6B2 >> 128;\\n        if (xSignifier & 0x20000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000162E42FEFA39EF358 >> 128;\\n        if (xSignifier & 0x10000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000B17217F7D1CF79AB >> 128;\\n        if (xSignifier & 0x8000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000058B90BFBE8E7BCD5 >> 128;\\n        if (xSignifier & 0x4000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000002C5C85FDF473DE6A >> 128;\\n        if (xSignifier & 0x2000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000162E42FEFA39EF34 >> 128;\\n        if (xSignifier & 0x1000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000B17217F7D1CF799 >> 128;\\n        if (xSignifier & 0x800000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000058B90BFBE8E7BCC >> 128;\\n        if (xSignifier & 0x400000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000002C5C85FDF473DE5 >> 128;\\n        if (xSignifier & 0x200000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000162E42FEFA39EF2 >> 128;\\n        if (xSignifier & 0x100000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000B17217F7D1CF78 >> 128;\\n        if (xSignifier & 0x80000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000058B90BFBE8E7BB >> 128;\\n        if (xSignifier & 0x40000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000002C5C85FDF473DD >> 128;\\n        if (xSignifier & 0x20000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000162E42FEFA39EE >> 128;\\n        if (xSignifier & 0x10000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000B17217F7D1CF6 >> 128;\\n        if (xSignifier & 0x8000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000058B90BFBE8E7A >> 128;\\n        if (xSignifier & 0x4000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000002C5C85FDF473C >> 128;\\n        if (xSignifier & 0x2000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000162E42FEFA39D >> 128;\\n        if (xSignifier & 0x1000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000B17217F7D1CE >> 128;\\n        if (xSignifier & 0x800000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000058B90BFBE8E6 >> 128;\\n        if (xSignifier & 0x400000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000002C5C85FDF472 >> 128;\\n        if (xSignifier & 0x200000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000162E42FEFA38 >> 128;\\n        if (xSignifier & 0x100000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000B17217F7D1B >> 128;\\n        if (xSignifier & 0x80000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000058B90BFBE8D >> 128;\\n        if (xSignifier & 0x40000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000002C5C85FDF46 >> 128;\\n        if (xSignifier & 0x20000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000162E42FEFA2 >> 128;\\n        if (xSignifier & 0x10000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000B17217F7D0 >> 128;\\n        if (xSignifier & 0x8000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000058B90BFBE7 >> 128;\\n        if (xSignifier & 0x4000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000002C5C85FDF3 >> 128;\\n        if (xSignifier & 0x2000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000162E42FEF9 >> 128;\\n        if (xSignifier & 0x1000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000B17217F7C >> 128;\\n        if (xSignifier & 0x800000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000058B90BFBD >> 128;\\n        if (xSignifier & 0x400000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000002C5C85FDE >> 128;\\n        if (xSignifier & 0x200000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000162E42FEE >> 128;\\n        if (xSignifier & 0x100000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000B17217F6 >> 128;\\n        if (xSignifier & 0x80000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000058B90BFA >> 128;\\n        if (xSignifier & 0x40000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000002C5C85FC >> 128;\\n        if (xSignifier & 0x20000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000162E42FD >> 128;\\n        if (xSignifier & 0x10000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000B17217E >> 128;\\n        if (xSignifier & 0x8000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000058B90BE >> 128;\\n        if (xSignifier & 0x4000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000002C5C85E >> 128;\\n        if (xSignifier & 0x2000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000162E42E >> 128;\\n        if (xSignifier & 0x1000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000B17216 >> 128;\\n        if (xSignifier & 0x800000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000058B90A >> 128;\\n        if (xSignifier & 0x400000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000002C5C84 >> 128;\\n        if (xSignifier & 0x200000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000162E41 >> 128;\\n        if (xSignifier & 0x100000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000B1720 >> 128;\\n        if (xSignifier & 0x80000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000058B8F >> 128;\\n        if (xSignifier & 0x40000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000002C5C7 >> 128;\\n        if (xSignifier & 0x20000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000162E3 >> 128;\\n        if (xSignifier & 0x10000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000B171 >> 128;\\n        if (xSignifier & 0x8000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000058B8 >> 128;\\n        if (xSignifier & 0x4000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000002C5B >> 128;\\n        if (xSignifier & 0x2000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000162D >> 128;\\n        if (xSignifier & 0x1000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000B16 >> 128;\\n        if (xSignifier & 0x800 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000058A >> 128;\\n        if (xSignifier & 0x400 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000002C4 >> 128;\\n        if (xSignifier & 0x200 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000161 >> 128;\\n        if (xSignifier & 0x100 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000000B0 >> 128;\\n        if (xSignifier & 0x80 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000057 >> 128;\\n        if (xSignifier & 0x40 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000002B >> 128;\\n        if (xSignifier & 0x20 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000015 >> 128;\\n        if (xSignifier & 0x10 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000000A >> 128;\\n        if (xSignifier & 0x8 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000004 >> 128;\\n        if (xSignifier & 0x4 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000001 >> 128;\\n\\n        if (!xNegative) {\\n          resultSignifier = resultSignifier >> 15 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          resultExponent += 0x3FFF;\\n        } else if (resultExponent <= 0x3FFE) {\\n          resultSignifier = resultSignifier >> 15 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          resultExponent = 0x3FFF - resultExponent;\\n        } else {\\n          resultSignifier = resultSignifier >> resultExponent - 16367;\\n          resultExponent = 0;\\n        }\\n\\n        return bytes16 (uint128 (resultExponent << 112 | resultSignifier));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate e^x.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function exp (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      return pow_2 (mul (x, 0x3FFF71547652B82FE1777D0FFDA0D23A));\\n    }\\n  }\\n\\n  /**\\n   * Get index of the most significant non-zero bit in binary representation of\\n   * x.  Reverts if x is zero.\\n   *\\n   * @return index of the most significant non-zero bit in binary representation\\n   *         of x\\n   */\\n  function mostSignificantBit (uint256 x) private pure returns (uint256) {\\n    unchecked {\\n      require (x > 0);\\n\\n      uint256 result = 0;\\n\\n      if (x >= 0x100000000000000000000000000000000) { x >>= 128; result += 128; }\\n      if (x >= 0x10000000000000000) { x >>= 64; result += 64; }\\n      if (x >= 0x100000000) { x >>= 32; result += 32; }\\n      if (x >= 0x10000) { x >>= 16; result += 16; }\\n      if (x >= 0x100) { x >>= 8; result += 8; }\\n      if (x >= 0x10) { x >>= 4; result += 4; }\\n      if (x >= 0x4) { x >>= 2; result += 2; }\\n      if (x >= 0x2) result += 1; // No need to shift x anymore\\n\\n      return result;\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x9694a9f6fcadd4fa917efa674de42a74b8fbab8d68924f771ea5cc5e1a301434\",\"license\":\"BSD-4-Clause\"},\"contracts/libraries/PoolSwapLibrary.sol\":{\"content\":\"//SPDX-License-Identifier: CC-BY-NC-ND-4.0\\npragma solidity 0.8.7;\\n\\nimport \\\"abdk-libraries-solidity/ABDKMathQuad.sol\\\";\\n\\n/// @title Library for various useful (mostly) mathematical functions\\nlibrary PoolSwapLibrary {\\n    /// ABDKMathQuad-formatted representation of the number one\\n    bytes16 public constant ONE = 0x3fff0000000000000000000000000000;\\n\\n    /// ABDKMathQuad-formatted representation of negative zero\\n    bytes16 private constant NEGATIVE_ZERO = 0x80000000000000000000000000000000;\\n\\n    /// Maximum number of decimal places supported by this contract\\n    /// (ABDKMathQuad defines this but it's private)\\n    uint256 public constant MAX_DECIMALS = 18;\\n\\n    /// Maximum precision supportable via wad arithmetic (for this contract)\\n    uint256 public constant WAD_PRECISION = 10**18;\\n\\n    /// Information required to update a given user's aggregated balance\\n    struct UpdateData {\\n        bytes16 longPrice;\\n        bytes16 shortPrice;\\n        bytes16 mintingFeeRate;\\n        uint256 currentUpdateIntervalId;\\n        uint256 updateIntervalId;\\n        uint256 longMintSettlement;\\n        uint256 longBurnPoolTokens;\\n        uint256 shortMintSettlement;\\n        uint256 shortBurnPoolTokens;\\n        uint256 longBurnShortMintPoolTokens;\\n        uint256 shortBurnLongMintPoolTokens;\\n        bytes16 burnFee;\\n    }\\n\\n    /// Information about the result of calculating a user's updated aggregate balance\\n    struct UpdateResult {\\n        uint256 _newLongTokens; // Quantity of long pool tokens post-application\\n        uint256 _newShortTokens; // Quantity of short pool tokens post-application\\n        uint256 _longSettlementFee; // The fee taken from ShortBurnLongMint commits\\n        uint256 _shortSettlementFee; // The fee taken from ShortBurnLongMint commits\\n        uint256 _newSettlementTokens; // Quantity of settlement tokens post\\n    }\\n\\n    /// Information required to perform a price change (of the underlying asset)\\n    struct PriceChangeData {\\n        int256 oldPrice;\\n        int256 newPrice;\\n        uint256 longBalance;\\n        uint256 shortBalance;\\n        bytes16 leverageAmount;\\n        bytes16 fee;\\n    }\\n\\n    /**\\n     * @notice Calculates the ratio between two numbers\\n     * @dev Rounds any overflow towards 0. If either parameter is zero, the ratio is 0\\n     * @param _numerator The \\\"parts per\\\" side of the equation. If this is zero, the ratio is zero\\n     * @param _denominator The \\\"per part\\\" side of the equation. If this is zero, the ratio is zero\\n     * @return the ratio, as an ABDKMathQuad number (IEEE 754 quadruple precision floating point)\\n     */\\n    function getRatio(uint256 _numerator, uint256 _denominator) public pure returns (bytes16) {\\n        // Catch the divide by zero error.\\n        if (_denominator == 0) {\\n            return 0;\\n        }\\n        return ABDKMathQuad.div(ABDKMathQuad.fromUInt(_numerator), ABDKMathQuad.fromUInt(_denominator));\\n    }\\n\\n    /**\\n     * @notice Multiplies two numbers\\n     * @param x The number to be multiplied by `y`\\n     * @param y The number to be multiplied by `x`\\n     */\\n    function multiplyBytes(bytes16 x, bytes16 y) external pure returns (bytes16) {\\n        return ABDKMathQuad.mul(x, y);\\n    }\\n\\n    /**\\n     * @notice Performs a subtraction on two bytes16 numbers\\n     * @param x The number to be subtracted by `y`\\n     * @param y The number to subtract from `x`\\n     */\\n    function subtractBytes(bytes16 x, bytes16 y) external pure returns (bytes16) {\\n        return ABDKMathQuad.sub(x, y);\\n    }\\n\\n    /**\\n     * @notice Performs an addition on two bytes16 numbers\\n     * @param x The number to be added with `y`\\n     * @param y The number to be added with `x`\\n     */\\n    function addBytes(bytes16 x, bytes16 y) external pure returns (bytes16) {\\n        return ABDKMathQuad.add(x, y);\\n    }\\n\\n    /**\\n     * @notice Gets the short and long balances after the keeper rewards have been paid out\\n     *         Keeper rewards are paid proportionally to the short and long pool\\n     * @dev Assumes shortBalance + longBalance >= reward\\n     * @param reward Amount of keeper reward\\n     * @param shortBalance Short balance of the pool\\n     * @param longBalance Long balance of the pool\\n     * @return shortBalanceAfterFees Short balance of the pool after the keeper reward has been paid\\n     * @return longBalanceAfterFees Long balance of the pool after the keeper reward has been paid\\n     */\\n    function getBalancesAfterFees(\\n        uint256 reward,\\n        uint256 shortBalance,\\n        uint256 longBalance\\n    ) external pure returns (uint256, uint256) {\\n        bytes16 ratioShort = getRatio(shortBalance, shortBalance + longBalance);\\n\\n        uint256 shortFees = convertDecimalToUInt(multiplyDecimalByUInt(ratioShort, reward));\\n\\n        uint256 shortBalanceAfterFees = shortBalance - shortFees;\\n        uint256 longBalanceAfterFees = longBalance - (reward - shortFees);\\n\\n        // Return shortBalance and longBalance after rewards are paid out\\n        return (shortBalanceAfterFees, longBalanceAfterFees);\\n    }\\n\\n    /**\\n     * @notice Compares two decimal numbers\\n     * @param x The first number to compare\\n     * @param y The second number to compare\\n     * @return -1 if x < y, 0 if x = y, or 1 if x > y\\n     */\\n    function compareDecimals(bytes16 x, bytes16 y) public pure returns (int8) {\\n        return ABDKMathQuad.cmp(x, y);\\n    }\\n\\n    /**\\n     * @notice Converts an integer value to a compatible decimal value\\n     * @param amount The amount to convert\\n     * @return The amount as a IEEE754 quadruple precision number\\n     */\\n    function convertUIntToDecimal(uint256 amount) external pure returns (bytes16) {\\n        return ABDKMathQuad.fromUInt(amount);\\n    }\\n\\n    /**\\n     * @notice Converts a raw decimal value to a more readable uint256 value\\n     * @param ratio The value to convert\\n     * @return The converted value\\n     */\\n    function convertDecimalToUInt(bytes16 ratio) public pure returns (uint256) {\\n        return ABDKMathQuad.toUInt(ratio);\\n    }\\n\\n    /**\\n     * @notice Multiplies a decimal and an unsigned integer\\n     * @param a The first term\\n     * @param b The second term\\n     * @return The product of a*b as a decimal\\n     */\\n    function multiplyDecimalByUInt(bytes16 a, uint256 b) public pure returns (bytes16) {\\n        return ABDKMathQuad.mul(a, ABDKMathQuad.fromUInt(b));\\n    }\\n\\n    /**\\n     * @notice Divides two unsigned integers\\n     * @param a The dividend\\n     * @param b The divisor\\n     * @return The quotient\\n     */\\n    function divUInt(uint256 a, uint256 b) private pure returns (bytes16) {\\n        return ABDKMathQuad.div(ABDKMathQuad.fromUInt(a), ABDKMathQuad.fromUInt(b));\\n    }\\n\\n    /**\\n     * @notice Divides two integers\\n     * @param a The dividend\\n     * @param b The divisor\\n     * @return The quotient\\n     */\\n    function divInt(int256 a, int256 b) public pure returns (bytes16) {\\n        return ABDKMathQuad.div(ABDKMathQuad.fromInt(a), ABDKMathQuad.fromInt(b));\\n    }\\n\\n    /**\\n     * @notice Multiply an integer by a fraction\\n     * @notice number * numerator / denominator\\n     * @param number The number with which the fraction calculated from `numerator` and `denominator` will be multiplied\\n     * @param numerator The numerator of the fraction being multipled with `number`\\n     * @param denominator The denominator of the fraction being multipled with `number`\\n     * @return The result of multiplying number with numerator/denominator, as an integer\\n     */\\n    function mulFraction(\\n        uint256 number,\\n        uint256 numerator,\\n        uint256 denominator\\n    ) public pure returns (uint256) {\\n        if (denominator == 0) {\\n            return 0;\\n        }\\n        bytes16 multiplyResult = ABDKMathQuad.mul(ABDKMathQuad.fromUInt(number), ABDKMathQuad.fromUInt(numerator));\\n        bytes16 result = ABDKMathQuad.div(multiplyResult, ABDKMathQuad.fromUInt(denominator));\\n        return convertDecimalToUInt(result);\\n    }\\n\\n    /**\\n     * @notice Calculates the loss multiplier to apply to the losing pool. Includes the power leverage\\n     * @param ratio The ratio of new price to old price\\n     * @param direction The direction of the change. -1 if it's decreased, 0 if it hasn't changed, and 1 if it's increased\\n     * @param leverage The amount of leverage to apply\\n     * @return The multiplier\\n     */\\n    function getLossMultiplier(\\n        bytes16 ratio,\\n        int8 direction,\\n        bytes16 leverage\\n    ) public pure returns (bytes16) {\\n        // If decreased:  2 ^ (leverage * log2[(1 * new/old) + [(0 * 1) / new/old]])\\n        //              = 2 ^ (leverage * log2[(new/old)])\\n        // If increased:  2 ^ (leverage * log2[(0 * new/old) + [(1 * 1) / new/old]])\\n        //              = 2 ^ (leverage * log2([1 / new/old]))\\n        //              = 2 ^ (leverage * log2([old/new]))\\n        return\\n            ABDKMathQuad.pow_2(\\n                ABDKMathQuad.mul(leverage, ABDKMathQuad.log_2(direction < 0 ? ratio : ABDKMathQuad.div(ONE, ratio)))\\n            );\\n    }\\n\\n    /**\\n     * @notice Calculates the amount to take from the losing pool\\n     * @param lossMultiplier The multiplier to use\\n     * @param balance The balance of the losing pool\\n     */\\n    function getLossAmount(bytes16 lossMultiplier, uint256 balance) public pure returns (uint256) {\\n        return\\n            ABDKMathQuad.toUInt(\\n                ABDKMathQuad.mul(ABDKMathQuad.sub(ONE, lossMultiplier), ABDKMathQuad.fromUInt(balance))\\n            );\\n    }\\n\\n    /**\\n     * @notice Calculates the effect of a price change. This involves calculating how many funds to transfer from the losing pool to the other.\\n     * @dev This function should be called by the LeveragedPool\\n     * @dev The value transfer is calculated using a sigmoid function\\n     * @dev The sigmoid function used is defined as follows:\\n     *          when newPrice >= oldPrice\\n     *              losing_pool_multiplier = 2 / (1 + e^(-2 * L * (1 - (newPrice / oldPrice)))) - 1\\n     *          when newPrice < oldPrice\\n     *              losing_pool_multiplier = 2 / (1 + e^(-2 * L * (1 - (oldPrice / newPrice)))) - 1\\n     *          where\\n     *              e = euler's number\\n     *              L = leverage\\n     *              newPrice = the new oracle price\\n     *              oldPrice = the previous oracle price\\n     * @param longBalance Settlement token balance on the long side of the pool before the price change\\n     * @param shortBalance Settlement token balance on the short side of the pool before the price change\\n     * @param leverageAmount The leverage of the pool\\n     * @param oldPrice The previous price\\n     * @param newPrice The new price\\n     * @param fee The pool's annualised protocol fee\\n     * @return Resulting long balance\\n     * @return Resulting short balance\\n     * @return Resulting fees taken from long balance\\n     * @return Resulting fees taken from short balance\\n     */\\n    function calculateValueTransfer(\\n        uint256 longBalance,\\n        uint256 shortBalance,\\n        bytes16 leverageAmount,\\n        int256 oldPrice,\\n        int256 newPrice,\\n        bytes16 fee\\n    )\\n        external\\n        pure\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        // Copy into a struct (otherwise stack gets too deep)\\n        PriceChangeData memory priceChangeData = PoolSwapLibrary.PriceChangeData(\\n            oldPrice,\\n            newPrice,\\n            longBalance,\\n            shortBalance,\\n            leverageAmount,\\n            fee\\n        );\\n        // Calculate fees from long and short sides\\n        uint256 longFeeAmount = convertDecimalToUInt(\\n            multiplyDecimalByUInt(priceChangeData.fee, priceChangeData.longBalance)\\n        ) / PoolSwapLibrary.WAD_PRECISION;\\n        uint256 shortFeeAmount = convertDecimalToUInt(\\n            multiplyDecimalByUInt(priceChangeData.fee, priceChangeData.shortBalance)\\n        ) / PoolSwapLibrary.WAD_PRECISION;\\n\\n        priceChangeData.shortBalance -= shortFeeAmount;\\n        priceChangeData.longBalance -= longFeeAmount;\\n\\n        uint256 sumBeforePriceChange = priceChangeData.shortBalance + priceChangeData.longBalance;\\n\\n        if (newPrice >= oldPrice && priceChangeData.shortBalance > 0) {\\n            // Price increased\\n            // Using the sigmoid function defined in the function's natspec, move funds from short side to long side\\n            bytes16 ratio = divInt(priceChangeData.oldPrice, priceChangeData.newPrice);\\n            bytes16 poolMultiplier = sigmoid(leverageAmount, ratio);\\n\\n            priceChangeData.longBalance += ABDKMathQuad.toUInt(\\n                ABDKMathQuad.mul(ABDKMathQuad.fromUInt(priceChangeData.shortBalance), poolMultiplier)\\n            );\\n            priceChangeData.shortBalance = ABDKMathQuad.toUInt(\\n                ABDKMathQuad.mul(\\n                    ABDKMathQuad.fromUInt(priceChangeData.shortBalance),\\n                    ABDKMathQuad.sub(ONE, poolMultiplier)\\n                )\\n            );\\n        } else if (newPrice < oldPrice && priceChangeData.longBalance > 0) {\\n            // Price decreased\\n            // Using the sigmoid function defined in the function's natspec, move funds from long side to short side\\n            bytes16 ratio = divInt(priceChangeData.newPrice, priceChangeData.oldPrice);\\n            bytes16 poolMultiplier = sigmoid(leverageAmount, ratio);\\n\\n            priceChangeData.shortBalance += ABDKMathQuad.toUInt(\\n                ABDKMathQuad.mul(ABDKMathQuad.fromUInt(priceChangeData.longBalance), poolMultiplier)\\n            );\\n            priceChangeData.longBalance = ABDKMathQuad.toUInt(\\n                ABDKMathQuad.mul(\\n                    ABDKMathQuad.fromUInt(priceChangeData.longBalance),\\n                    ABDKMathQuad.sub(ONE, poolMultiplier)\\n                )\\n            );\\n        }\\n\\n        if (sumBeforePriceChange > priceChangeData.longBalance + priceChangeData.shortBalance) {\\n            // Move dust into winning side\\n            // This is only ever 1 wei (negligible)\\n            if (newPrice > oldPrice) {\\n                priceChangeData.longBalance +=\\n                    sumBeforePriceChange -\\n                    (priceChangeData.longBalance + priceChangeData.shortBalance);\\n            } else {\\n                priceChangeData.shortBalance +=\\n                    sumBeforePriceChange -\\n                    (priceChangeData.longBalance + priceChangeData.shortBalance);\\n            }\\n        }\\n\\n        return (priceChangeData.longBalance, priceChangeData.shortBalance, longFeeAmount, shortFeeAmount);\\n    }\\n\\n    /**\\n     * @notice Use a sigmoid function to determine the losing pool multiplier.\\n     * @return The losing pool multiplier, represented as an ABDKMathQuad IEEE754 quadruple-precision binary floating-point numbers\\n     * @dev The returned value is used in `calculateValueTransfer` as the portion to move from the losing side into the winning side\\n     */\\n    function sigmoid(bytes16 leverage, bytes16 ratio) private pure returns (bytes16) {\\n        /**\\n         * denominator = 1 + e ^ (-2 * leverage * (1 - ratio))\\n         */\\n        bytes16 denominator = ABDKMathQuad.mul(ABDKMathQuad.fromInt(-2), leverage);\\n        denominator = ABDKMathQuad.mul(denominator, ABDKMathQuad.sub(ONE, ratio));\\n        denominator = ABDKMathQuad.add(ONE, ABDKMathQuad.exp(denominator));\\n        bytes16 numerator = ABDKMathQuad.add(ONE, ONE); // 2\\n        return ABDKMathQuad.sub((ABDKMathQuad.div(numerator, denominator)), ONE);\\n    }\\n\\n    /**\\n     * @notice Returns true if the given timestamp is BEFORE the frontRunningInterval starts\\n     * @param subjectTime The timestamp for which you want to calculate if it was beforeFrontRunningInterval\\n     * @param lastPriceTimestamp The timestamp of the last price update\\n     * @param updateInterval The interval between price updates\\n     * @param frontRunningInterval The window of time before a price update in which users can have their commit executed from\\n     */\\n    function isBeforeFrontRunningInterval(\\n        uint256 subjectTime,\\n        uint256 lastPriceTimestamp,\\n        uint256 updateInterval,\\n        uint256 frontRunningInterval\\n    ) public pure returns (bool) {\\n        return lastPriceTimestamp + updateInterval - frontRunningInterval > subjectTime;\\n    }\\n\\n    /**\\n     * @notice Calculates the update interval ID that a commitment should be placed in.\\n     * @param timestamp Current block.timestamp\\n     * @param lastPriceTimestamp The timestamp of the last price update\\n     * @param frontRunningInterval The frontrunning interval of a pool - The amount of time before an update interval that you must commit to get included in that update\\n     * @param updateInterval The frequency of a pool's updates\\n     * @param currentUpdateIntervalId The current update interval's ID\\n     * @dev Note that the timestamp parameter is required to be >= lastPriceTimestamp\\n     * @return The update interval ID in which a commit being made at time timestamp should be included\\n     */\\n    function appropriateUpdateIntervalId(\\n        uint256 timestamp,\\n        uint256 lastPriceTimestamp,\\n        uint256 frontRunningInterval,\\n        uint256 updateInterval,\\n        uint256 currentUpdateIntervalId\\n    ) external pure returns (uint256) {\\n        require(lastPriceTimestamp <= timestamp, \\\"timestamp in the past\\\");\\n        if (frontRunningInterval <= updateInterval) {\\n            // This is the \\\"simple\\\" case where we either want the current update interval or the next one\\n            if (isBeforeFrontRunningInterval(timestamp, lastPriceTimestamp, updateInterval, frontRunningInterval)) {\\n                // We are before the frontRunning interval\\n                return currentUpdateIntervalId;\\n            } else {\\n                // Floor of `timePassed / updateInterval` to get the number of intervals passed\\n                uint256 updateIntervalsPassed = (timestamp - lastPriceTimestamp) / updateInterval;\\n                // If 1 update interval has passed, we want to check if we are within the frontrunning interval of currentUpdateIntervalId + 1\\n                uint256 frontRunningIntervalStart = lastPriceTimestamp +\\n                    ((updateIntervalsPassed + 1) * updateInterval) -\\n                    frontRunningInterval;\\n                if (timestamp >= frontRunningIntervalStart) {\\n                    // add an extra update interval because the frontrunning interval has passed\\n                    return currentUpdateIntervalId + updateIntervalsPassed + 1;\\n                } else {\\n                    return currentUpdateIntervalId + updateIntervalsPassed;\\n                }\\n            }\\n        } else {\\n            // frontRunningInterval > updateInterval\\n            // This is the generalised case, where it could be any number of update intervals in the future\\n            // Minimum time is the earliest we could possible execute this commitment (i.e. the current time plus frontrunning interval)\\n            uint256 minimumTime = timestamp + frontRunningInterval;\\n            // Number of update intervals that would have had to have passed.\\n            uint256 updateIntervals = (minimumTime - lastPriceTimestamp) / updateInterval;\\n\\n            return currentUpdateIntervalId + updateIntervals;\\n        }\\n    }\\n\\n    /**\\n     * @notice Gets the number of settlement tokens to be withdrawn based on a pool token burn amount\\n     * @dev Calculates as `balance * amountIn / (tokenSupply + shadowBalance)\\n     * @param tokenSupply Total supply of pool tokens\\n     * @param amountIn Commitment amount of pool tokens going into the pool\\n     * @param balance Balance of the pool (no. of underlying settlement tokens in pool)\\n     * @param pendingBurnPoolTokens Amount of pool tokens being burnt during this update interval\\n     * @return Number of settlement tokens to be withdrawn on a burn\\n     */\\n    function getWithdrawAmountOnBurn(\\n        uint256 tokenSupply,\\n        uint256 amountIn,\\n        uint256 balance,\\n        uint256 pendingBurnPoolTokens\\n    ) external pure returns (uint256) {\\n        // Catch the divide by zero error, or return 0 if amountIn is 0\\n        if ((balance == 0) || (tokenSupply + pendingBurnPoolTokens == 0) || (amountIn == 0)) {\\n            return amountIn;\\n        }\\n        return (balance * amountIn) / (tokenSupply + pendingBurnPoolTokens);\\n    }\\n\\n    /**\\n     * @notice Gets the number of pool tokens to be minted based on existing tokens\\n     * @dev Calculated as (tokenSupply + shadowBalance) * amountIn / balance\\n     * @param tokenSupply Total supply of pool tokens\\n     * @param amountIn Commitment amount of settlement tokens going into the pool\\n     * @param balance Balance of the pool (no. of underlying settlement tokens in pool)\\n     * @param pendingBurnPoolTokens Amount of pool tokens being burnt during this update interval\\n     * @return Number of pool tokens to be minted\\n     */\\n    function getMintAmount(\\n        uint256 tokenSupply,\\n        uint256 amountIn,\\n        uint256 balance,\\n        uint256 pendingBurnPoolTokens\\n    ) external pure returns (uint256) {\\n        // Catch the divide by zero error, or return 0 if amountIn is 0\\n        if (balance == 0 || tokenSupply + pendingBurnPoolTokens == 0 || amountIn == 0) {\\n            return amountIn;\\n        }\\n\\n        return ((tokenSupply + pendingBurnPoolTokens) * amountIn) / balance;\\n    }\\n\\n    /**\\n     * @notice Get the Settlement/PoolToken price, in ABDK IEE754 precision\\n     * @dev Divide the side balance by the pool token's total supply\\n     * @param sideBalance no. of underlying settlement tokens on that side of the pool\\n     * @param tokenSupply Total supply of pool tokens\\n     */\\n    function getPrice(uint256 sideBalance, uint256 tokenSupply) external pure returns (bytes16) {\\n        if (tokenSupply == 0) {\\n            return ONE;\\n        }\\n        return ABDKMathQuad.div(ABDKMathQuad.fromUInt(sideBalance), ABDKMathQuad.fromUInt(tokenSupply));\\n    }\\n\\n    /**\\n     * @notice Calculates the number of pool tokens to mint, given some settlement token amount and a price\\n     * @param price Price of a pool token\\n     * @param amount Amount of settlement tokens being used to mint\\n     * @return Quantity of pool tokens to mint\\n     * @dev Throws if price is zero, or IEEE754 negative zero\\n     * @dev `getMint()`\\n     */\\n    function getMint(bytes16 price, uint256 amount) public pure returns (uint256) {\\n        require(price != 0, \\\"price == 0\\\");\\n        require(price != NEGATIVE_ZERO, \\\"price == negative zero\\\");\\n        return ABDKMathQuad.toUInt(ABDKMathQuad.div(ABDKMathQuad.fromUInt(amount), price));\\n    }\\n\\n    /**\\n     * @notice Calculate the number of settlement tokens to return, based on a price and an amount of pool tokens being burnt\\n     * @param price Price of a pool token\\n     * @param amount Amount of pool tokens being used to burn\\n     * @return Quantity of settlement tokens to return to the user after `amount` pool tokens are burnt.\\n     * @dev amount * price, where amount is in PoolToken and price is in USD/PoolToken\\n     * @dev Throws if price is zero, or IEEE754 negative zero\\n     * @dev `getBurn()`\\n     */\\n    function getBurn(bytes16 price, uint256 amount) public pure returns (uint256) {\\n        require(price != 0, \\\"price == 0\\\");\\n        require(price != NEGATIVE_ZERO, \\\"price == negative zero\\\");\\n        return ABDKMathQuad.toUInt(ABDKMathQuad.mul(ABDKMathQuad.fromUInt(amount), price));\\n    }\\n\\n    /**\\n     * @notice Calculate the amount of settlement tokens to take as the minting fee\\n     * @param feeRate PoolCommitter's mintingFee or burningFee - The amount that is extracted from each mint or burn. Given as the decimal * 10 ^ 18. For example, 60% fee is 0.6 * 10 ^ 18 Fees can be 0.\\n     * @param amount The amount of settlement tokens being committed to mint\\n     */\\n    function mintingOrBurningFee(bytes16 feeRate, uint256 amount) public pure returns (uint256) {\\n        return ABDKMathQuad.toUInt(multiplyDecimalByUInt(feeRate, amount)) / WAD_PRECISION;\\n    }\\n\\n    /**\\n     * @notice Converts from a WAD to normal value\\n     * @param _wadValue wad number\\n     * @param _decimals Quantity of decimal places to support\\n     * @return Converted (non-WAD) value\\n     */\\n    function fromWad(uint256 _wadValue, uint256 _decimals) external pure returns (uint256) {\\n        uint256 scaler = 10**(MAX_DECIMALS - _decimals);\\n        return _wadValue / scaler;\\n    }\\n\\n    /**\\n     * @notice Given an amount of pool tokens to flip to the other side of the pool, calculate the amount of settlement tokens generated from the burn, burn fee, and subsequent minting fee\\n     * @dev Takes out the burn fee before taking out the mint fee.\\n     * @param amount The amount of pool tokens being flipped\\n     * @param burnPrice The price of the pool token being burnt\\n     * @param burningFee Fee rate for pool token burns\\n     * @param mintingFee Fee rate for mints\\n     * @return Amount of settlement tokens used to mint.\\n     * @return The burn fee. This should be given to the side of the pool of the burnt tokens.\\n     * @return The mint fee. This should be given to the side of the pool that is being minted into.\\n     */\\n    function processBurnInstantMintCommit(\\n        uint256 amount,\\n        bytes16 burnPrice,\\n        bytes16 burningFee,\\n        bytes16 mintingFee\\n    )\\n        public\\n        pure\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        // Settlement tokens earned from burning pool tokens (for instant mint)\\n        uint256 mintSettlement = getBurn(burnPrice, amount);\\n        // The burn fee. This should be given to the side of the pool of the burnt tokens.\\n        uint256 burnFee = mintingOrBurningFee(burningFee, mintSettlement);\\n        mintSettlement -= burnFee;\\n\\n        // The mint fee. This should be given to the side of the pool that is being minted into.\\n        uint256 mintFee = mintingOrBurningFee(mintingFee, mintSettlement);\\n        mintSettlement -= mintFee;\\n        return (mintSettlement, burnFee, mintFee);\\n    }\\n\\n    /**\\n     * @notice Calculate the change in a user's balance based on recent commit(s)\\n     * @param data Information needed for updating the balance including prices and recent commit amounts\\n     * @return The UpdateResult struct with the data pertaining to the update of user's aggregate balance\\n     */\\n    function getUpdatedAggregateBalance(UpdateData calldata data) external pure returns (UpdateResult memory) {\\n        UpdateResult memory result = UpdateResult(0, 0, 0, 0, 0);\\n        if (data.updateIntervalId >= data.currentUpdateIntervalId) {\\n            // Update interval has not passed: No change\\n            return result;\\n        }\\n\\n        /**\\n         * Start by looking at the \\\"flip\\\" commitments (either LongBurnShortMint, or ShortBurnLongMint), and determine the amount of settlement tokens were generated from them.\\n         * Then, take the burning fee off them and add that to the relevant side's fee amount. e.g. a ShortBurnLongMint will generate burn fees for the short side.\\n         * Now, we can calculate how much minting fee should be paid by the user. This should then be added to the side which they are minting on.\\n         */\\n        uint256 shortBurnLongMintResult; // Settlement to be included in the long mint\\n        uint256 longBurnShortMintResult; // Settlement to be included in the short mint\\n        if (data.shortBurnLongMintPoolTokens > 0) {\\n            uint256 burnFeeSettlement;\\n            uint256 mintFeeSettlement;\\n            (shortBurnLongMintResult, burnFeeSettlement, mintFeeSettlement) = processBurnInstantMintCommit(\\n                data.shortBurnLongMintPoolTokens,\\n                data.shortPrice,\\n                data.burnFee,\\n                data.mintingFeeRate\\n            );\\n            result._shortSettlementFee += burnFeeSettlement;\\n            result._longSettlementFee += mintFeeSettlement;\\n        }\\n        if (data.longBurnShortMintPoolTokens > 0) {\\n            // Settlement tokens earned from burning long tokens (for instant mint)\\n            longBurnShortMintResult = getBurn(data.longPrice, data.longBurnShortMintPoolTokens);\\n            // The burn fee taken from this burn. This should be given to the long side.\\n            uint256 burnFeeSettlement = mintingOrBurningFee(data.burnFee, longBurnShortMintResult);\\n            longBurnShortMintResult -= burnFeeSettlement;\\n\\n            // The mint fee taken from the subsequent mint\\n            uint256 mintFeeSettlement = mintingOrBurningFee(data.mintingFeeRate, longBurnShortMintResult);\\n            longBurnShortMintResult -= mintFeeSettlement;\\n\\n            result._longSettlementFee += burnFeeSettlement;\\n            result._shortSettlementFee += mintFeeSettlement;\\n        }\\n\\n        /**\\n         * Calculate the new long tokens minted.\\n         * Use amount committed LongMint/ShortMint, as well as settlement tokens generated from ShortBurnLongMint/LongBurnShortMint commits.\\n         */\\n        if (data.longMintSettlement > 0 || shortBurnLongMintResult > 0) {\\n            result._newLongTokens += getMint(data.longPrice, data.longMintSettlement + shortBurnLongMintResult);\\n        }\\n        if (data.shortMintSettlement > 0 || longBurnShortMintResult > 0) {\\n            result._newShortTokens += getMint(data.shortPrice, data.shortMintSettlement + longBurnShortMintResult);\\n        }\\n\\n        /**\\n         * Calculate the settlement tokens earned through LongBurn/ShortBurn commits.\\n         * Once this is calculated, take off the burn fee, and add to the respective side's fee amount.\\n         */\\n        if (data.longBurnPoolTokens > 0) {\\n            // Calculate the amount of settlement tokens earned from burning long tokens\\n            uint256 longBurnResult = getBurn(data.longPrice, data.longBurnPoolTokens);\\n            // Calculate the fee\\n            uint256 longBurnFee = mintingOrBurningFee(data.burnFee, longBurnResult);\\n            result._longSettlementFee += longBurnFee;\\n            // Subtract the fee from settlement token amount\\n            longBurnResult -= longBurnFee;\\n            result._newSettlementTokens += longBurnResult;\\n        }\\n        if (data.shortBurnPoolTokens > 0) {\\n            // Calculate the amount of settlement tokens earned from burning short tokens\\n            uint256 shortBurnResult = getBurn(data.shortPrice, data.shortBurnPoolTokens);\\n            // Calculate the fee\\n            uint256 shortBurnFee = mintingOrBurningFee(data.burnFee, shortBurnResult);\\n            result._shortSettlementFee += shortBurnFee;\\n            // Subtract the fee from settlement token amount\\n            shortBurnResult -= shortBurnFee;\\n            result._newSettlementTokens += shortBurnResult;\\n        }\\n\\n        return result;\\n    }\\n}\\n\",\"keccak256\":\"0xb03e3b47d1bb12966bf15030a1b340f09e573e60012770338468245a1abeb33a\",\"license\":\"CC-BY-NC-ND-4.0\"}},\"version\":1}",
  "bytecode": "0x61362061003a600b82828239805160001a60731461002d57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106101ce5760003560e01c8063aeb64d7d11610103578063dc35bc13116100a1578063e45639451161007b578063e456394514610466578063fc31158114610479578063fea3de331461048c578063ff9afe871461049f57600080fd5b8063dc35bc1314610418578063debb52df14610440578063dfdbe4da1461045357600080fd5b8063bf36f0e9116100dd578063bf36f0e9146103d3578063c2ee3a08146103e6578063c3ff8091146103f2578063cff700011461040557600080fd5b8063aeb64d7d1461037a578063b6b2f9f61461038d578063b89bf2ef146103a057600080fd5b8063664808a8116101705780639eb17fa31161014a5780639eb17fa3146102ec578063a818c0d214610341578063aacf0ecb14610354578063ab41556f1461036757600080fd5b8063664808a81461028c57806381a799db1461029b578063839dff3d146102be57600080fd5b8063202f1257116101ac578063202f125714610240578063422051e71461025357806345e7ef9b146102665780635cf4ee911461027957600080fd5b80630417cf8e146101d35780630e8418dd146101ee5780631842c9d81461021a575b600080fd5b6101db601281565b6040519081526020015b60405180910390f35b6102016101fc366004613213565b6104b2565b6040516001600160801b031990911681526020016101e5565b61022d610228366004613213565b6104c7565b60405160009190910b81526020016101e5565b61020161024e3660046132bb565b6104d3565b610201610261366004613291565b6104ef565b610201610274366004613213565b610503565b6102016102873660046132bb565b61050f565b6101db670de0b6b3a764000081565b6102ae6102a93660046133e0565b610537565b60405190151581526020016101e5565b6102d16102cc36600461330f565b61055b565b604080519384526020840192909252908201526060016101e5565b6102ff6102fa3660046132dd565b6105ae565b6040516101e59190600060a082019050825182526020830151602083015260408301516040830152606083015160608301526080830151608083015292915050565b6101db61034f366004613291565b6108ed565b6101db610362366004613291565b610912565b6101db6103753660046133e0565b610934565b6101db6103883660046131f8565b610988565b61020161039b366004613213565b610993565b6103b36103ae36600461335c565b61099f565b6040805194855260208501939093529183015260608201526080016101e5565b6101db6103e13660046132bb565b610c50565b610201613fff60f01b81565b610201610400366004613246565b610c75565b6102016104133660046132bb565b610cb5565b61042b6104263660046133b4565b610cc4565b604080519283526020830191909152016101e5565b6101db61044e3660046133e0565b610d1d565b6102016104613660046132f6565b610d5c565b6101db610474366004613291565b610d67565b6101db610487366004613291565b610e1e565b6101db61049a3660046133b4565b610ed0565b6101db6104ad366004613412565b610f1c565b60006104be838361102d565b90505b92915050565b60006104be838361103f565b60006104be6104e184611166565b6104ea84611166565b6111f9565b60006104be836104fe846114b0565b611514565b60006104be8383611514565b6000816105225750613fff60f01b6104c1565b6104be61052e846114b0565b6104ea846114b0565b60008482610545858761344d565b61054f9190613591565b1190505b949350505050565b60008060008061056b8789610e1e565b905060006105798783610912565b90506105858183613591565b915060006105938784610912565b905061059f8184613591565b9a919950975095505050505050565b6105e06040518060a0016040528060008152602001600081526020016000815260200160008152602001600081525090565b60006040518060a00160405280600081526020016000815260200160008152602001600081526020016000815250905082606001358360800135106106255792915050565b600080610140850135156106a95760008061067161014088013561064f60408a0160208b016131f8565b6106616101808b016101608c016131f8565b6102cc60608c0160408d016131f8565b6060880180519397509194509250839161068c90839061344d565b9052506040850180518291906106a390839061344d565b90525050505b61012085013515610754576106cf6106c460208701876131f8565b866101200135610e1e565b905060006106ee6106e8610180880161016089016131f8565b83610912565b90506106fa8183613591565b915060006107176107116060890160408a016131f8565b84610912565b90506107238184613591565b92508185604001818151610737919061344d565b90525060608501805182919061074e90839061344d565b90525050505b60008560a0013511806107675750600082115b1561079d5761078a61077c60208701876131f8565b6104748460a089013561344d565b8351849061079990839061344d565b9052505b60008560e0013511806107b05750600081115b156107eb576107d66107c860408701602088016131f8565b6104748360e089013561344d565b836020018181516107e7919061344d565b9052505b60c08501351561086557600061081161080760208801886131f8565b8760c00135610e1e565b9050600061082a6106e861018089016101608a016131f8565b9050808560400181815161083e919061344d565b90525061084b8183613591565b9150818560800181815161085f919061344d565b90525050505b610100850135156108e457600061089061088560408801602089016131f8565b876101000135610e1e565b905060006108a96106e861018089016101608a016131f8565b905080856060018181516108bd919061344d565b9052506108ca8183613591565b915081856080018181516108de919061344d565b90525050505b50909392505050565b60006104be61090d610904613fff60f01b8661102d565b6104fe856114b0565b61176f565b6000670de0b6b3a764000061092a61090d85856104ef565b6104be9190613465565b600082158061094a5750610948828661344d565b155b80610953575083155b1561095f575082610553565b828461096b848861344d565b6109759190613572565b61097f9190613465565b95945050505050565b60006104c18261176f565b60006104be83836117f2565b60008060008060006040518060c001604052808981526020018881526020018c81526020018b81526020018a6001600160801b0319168152602001876001600160801b03191681525090506000670de0b6b3a7640000610a0a6103888460a0015185604001516104ef565b610a149190613465565b90506000670de0b6b3a7640000610a366103888560a0015186606001516104ef565b610a409190613465565b90508083606001818151610a549190613591565b905250604083018051839190610a6b908390613591565b90525060408301516060840151600091610a849161344d565b90508a8a12158015610a9a575060008460600151115b15610b22576000610ab3856000015186602001516104d3565b90506000610ac18e83611bb2565b9050610adc61090d610ad688606001516114b0565b83611514565b86604001818151610aed919061344d565b9052506060860151610b159061090d90610b06906114b0565b6104fe613fff60f01b8561102d565b606087015250610ba39050565b8a8a128015610b35575060008460400151115b15610ba3576000610b4e856020015186600001516104d3565b90506000610b5c8e83611bb2565b9050610b7161090d610ad688604001516114b0565b86606001818151610b82919061344d565b9052506040860151610b9b9061090d90610b06906114b0565b604087015250505b83606001518460400151610bb7919061344d565b811115610c30578a8a1315610bfd5783606001518460400151610bda919061344d565b610be49082613591565b84604001818151610bf5919061344d565b905250610c30565b83606001518460400151610c11919061344d565b610c1b9082613591565b84606001818151610c2c919061344d565b9052505b506040830151606090930151929d929c50909a5098509650505050505050565b600080610c5e836012613591565b610c6990600a6134ca565b90506105538185613465565b6000610cab610ca6836104fe60008760000b12610ca057610c9b613fff60f01b896111f9565b611c1e565b87611c1e565b611dce565b90505b9392505050565b600081610522575060006104c1565b60008080610cd685610413868261344d565b90506000610ce761038883896104ef565b90506000610cf58288613591565b90506000610d03838a613591565b610d0d9088613591565b9199919850909650505050505050565b6000821580610d335750610d31828661344d565b155b80610d3c575083155b15610d48575082610553565b610d52828661344d565b6109758585613572565b60006104c1826114b0565b60006001600160801b03198316610db25760405162461bcd60e51b815260206004820152600a60248201526907072696365203d3d20360b41b60448201526064015b60405180910390fd5b6001600160801b03198316600160ff1b1415610e095760405162461bcd60e51b81526020600482015260166024820152757072696365203d3d206e65676174697665207a65726f60501b6044820152606401610da9565b6104be61090d610e18846114b0565b856111f9565b60006001600160801b03198316610e645760405162461bcd60e51b815260206004820152600a60248201526907072696365203d3d20360b41b6044820152606401610da9565b6001600160801b03198316600160ff1b1415610ebb5760405162461bcd60e51b81526020600482015260166024820152757072696365203d3d206e65676174697665207a65726f60501b6044820152606401610da9565b6104be61090d610eca846114b0565b85611514565b600081610edf57506000610cae565b6000610ef6610eed866114b0565b6104fe866114b0565b90506000610f07826104ea866114b0565b9050610f1281610988565b9695505050505050565b600085851115610f665760405162461bcd60e51b81526020600482015260156024820152741d1a5b595cdd185b5c081a5b881d1a19481c185cdd605a1b6044820152606401610da9565b828411610ffc57610f7986868587610537565b15610f8557508061097f565b600083610f928789613591565b610f9c9190613465565b905060008585610fad84600161344d565b610fb79190613572565b610fc1908961344d565b610fcb9190613591565b9050808810610ff257610fde828561344d565b610fe990600161344d565b9250505061097f565b610fe9828561344d565b6000611008858861344d565b90506000846110178884613591565b6110219190613465565b9050610fe9818561344d565b60006104be83600160ff1b84186117f2565b600060016001607f1b03608084901c16617fff60701b81111561106157600080fd5b60016001607f1b03608084901c16617fff60701b81111561108157600080fd5b6001600160801b03198581169085161415806110aa5750617fff60701b826001600160801b0316105b6110b357600080fd5b6001600160801b031985811690851614156110d3576000925050506104c1565b6001607f1b608086811c82118015929187901c91909110159061112557801561111657826001600160801b0316846001600160801b03161161111657600161111a565b6000195b9450505050506104c1565b80156111385760019450505050506104c1565b826001600160801b0316846001600160801b0316116111595760001961111a565b60019450505050506104c1565b60008161117557506000919050565b60008083136111875782600003611189565b825b9050600061119682613120565b905060708110156111af578060700382901b91506111c2565b60708111156111c2576070810382901c91505b6001600160701b03909116613fff820160701b179060008412156111ea576001607f1b821791505b5060801b92915050565b919050565b6000617fff60f084811c8216919084901c81169082141561123f5780617fff141561122e575061ffff60ef1b91506104c19050565b505050600160ff1b811682186104c1565b80617fff1415611283576dffffffffffffffffffffffffffff60801b841615611272575061ffff60ef1b91506104c19050565b505050808218600160ff1b166104c1565b600160801b600160ff1b0384166112cd57600160801b600160ff1b0385166112b5575061ffff60ef1b91506104c19050565b505050808218600160ff1b16617fff60f01b176104c1565b6001600160701b03608085901c16816112e957600191506112f0565b600160701b175b6001600160701b03608087901c168361132f57801561132a57600061131482613120565b6001955060e20393840160711901939190911b90505b611339565b600160701b1760721b5b818181611348576113486135d4565b0490508061137457600160ff1b8787181661136457600061111a565b600160ff1b9450505050506104c1565b6001606c1b811015611388576113886135a8565b6000600160731b8210156113c757600160721b8210156113bc57600160711b8210156113b55760706113bf565b60716113bf565b60725b60ff166113d0565b6113d082613120565b9050836140710181860111156113ee57617fff945060009150611481565b83818601613ffc011015611409576000945060009150611481565b83818601613f8c011015611456578385613ffc011115611434578385613ffc010382901b915061144d565b8385613ffc01101561144d57613ffc8585030382901c91505b60009450611481565b6070811115611469576070810382901c91505b6001600160701b038216915083818601613f8d010394505b81607086901b888a186001607f1b60801b1660801c6001600160801b0316171760801b955050505050506104c1565b6000816114bf57506000919050565b8160006114cb82613120565b905060708110156114e4578060700382901b91506114f7565b60708111156114f7576070810382901c91505b613fff0160701b6001600160701b03919091161760801b92915050565b6000617fff60f084811c8216919084901c8116908214156115b35780617fff1415611592576001600160801b0319858116908516141561155f57505050600160ff1b811682186104c1565b600160ff1b6001600160801b0319868618161415611582575050508181176104c1565b5061ffff60ef1b91506104c19050565b600160801b600160ff1b03841661122e575061ffff60ef1b91506104c19050565b80617fff14156115ef57600160801b600160ff1b0385166115de575061ffff60ef1b91506104c19050565b505050600160ff1b821681186104c1565b6001600160701b03608086901c168261160b5760019250611612565b600160701b175b6001600160701b03608086901c168261162e5760019250611635565b600160701b175b908102908161165257600160ff1b8787181661136457600061111a565b928201926000600160e11b83101561168557600160e01b83101561167e5761167983613120565b611688565b60e0611688565b60e15b905061407081860110156116a3576000945060009250611740565b6140e081860110156116e6576140708510156116c857846140700383901c92506116dd565b6140708511156116dd57614070850383901b92505b60009450611740565b61c0dd818601111561170057617fff945060009250611740565b6070811115611717576070810383901c925061172a565b607081101561172a578060700383901b92505b6001600160701b03831692506140df8186010394505b82607086901b888a186001607f1b60801b1660801c6001600160801b0316171760801b955050505050506104c1565b6000617fff60f083901c16613fff81101561178d5750600092915050565b6001607f1b608084901c106117a157600080fd5b6140fe8111156117b057600080fd5b600160701b6001600160701b03608085901c161761406f8210156117da5761406f8290031c610cae565b61406f821115610cae5761406e1982011b9392505050565b6000617fff60f084811c8216919084901c8116908214156118405780617fff1415611836576001600160801b031985811690851614156115825784925050506104c1565b84925050506104c1565b80617fff14156118545783925050506104c1565b6001607f1b608086901c90811015906001600160701b03168361187a5760019350611881565b600160701b175b6001607f1b608087901c90811015906001600160701b0316846118a757600194506118ae565b600160701b175b826118de576001600160801b03198816600160ff1b146118ce57876118d1565b60005b96505050505050506104c1565b806118fe576001600160801b03198916600160ff1b146118ce57886118d1565b8486038415158315151415611a0957607081131561192557899750505050505050506104c1565b60008113156119375790811c90611966565b606f1981121561195057889750505050505050506104c1565b6000811215611966578060000384901c93508596505b92810192600160711b8410611981576001968701969390931c925b86617fff14156119b3578461199b57617fff60f01b6119a5565b6001600160f01b03195b9750505050505050506104c1565b600160701b8410156119c857600096506119d5565b6001600160701b03841693505b83607088901b866119e75760006119ed565b6001607f1b5b6001600160801b0316171760801b9750505050505050506104c1565b6000811315611a2457600184901b9350600187039650611a3b565b6000811215611a3b57600182901b91506001860396505b6070811315611a4d5760019150611a9a565b6001811315611a6a576001810360018303901c6001019150611a9a565b606f19811215611a7d5760019350611a9a565b600019811215611a9a576001816000030360018503901c60010193505b818410611aab578184039350611ab4565b83820393508294505b83611aca5750600096506104c195505050505050565b6000611ad585613120565b90508060711415611afb57600185901c6001600160701b03169450600188019750611b4a565b6070811015611b3d57607081900380891115611b2a578086901b6001600160701b031695508089039850611b37565b600098600019019590951b945b50611b4a565b6001600160701b03851694505b87617fff1415611b7d5785611b6457617fff60f01b611b6e565b6001600160f01b03195b985050505050505050506104c1565b84607089901b87611b8f576000611b95565b6001607f1b5b6001600160801b0316171760801b985050505050505050506104c1565b600080611bc3610eca600119611166565b9050611bd8816104fe613fff60f01b8661102d565b9050611bf1613fff60f01b611bec836131be565b6117f2565b90506000611c04613fff60f01b806117f2565b905061097f611c1382846111f9565b613fff60f01b61102d565b60006001607f1b608083901c1115611c3c575061ffff60ef1b919050565b613fff60f01b6001600160801b031983161415611c5b57506000919050565b617fff60f083901c811690811415611c74575090919050565b6001600160701b03608084901c1681611c905760019150611c97565b600160701b175b80611cad57506001600160f01b03199392505050565b600061406f81613fff8510611cd35750600f9290921b9160009150613ffe198401611d12565b60019250600160701b8410611cf55784613ffe039050600f84901b9350611d12565b6000611d0085613120565b607f8190039590951b9461406d039150505b836001607f1b1415611d46578215611d28576001015b6000611d3382613120565b60700392839003929190911b9050611d94565b600083611d54576000611d57565b60015b60ff1690505b600160701b821015611d925793800260ff81901c607f81019190911c94600019939093019260019290921b9082180190611d5d565b505b806001600160701b0316607083901b84611daf576000611db5565b6001607f1b5b6001600160801b0316171760801b979650505050505050565b60006001607f1b608083901c90811190617fff60f085901c8116916001600160701b03169082148015611e0057508015155b15611e14575061ffff60ef1b949350505050565b61400d821115611e395782611e2e57617fff60f01b61097f565b600095945050505050565b613f7f821015611e525750613fff60f01b949350505050565b81611e605760019150611e67565b600160701b175b613fef821115611e7d57613fee1982011b611e8f565b613fef821015611e8f57613fef8290031c5b828015611ea0575061203760811b81115b15611eb057506000949350505050565b82158015611ecf5750713fffffffffffffffffffffffffffffffffff81115b15611ee35750617fff60f01b949350505050565b6001600160801b0381169060801c838015611efd57508115155b15611f09579019906001015b6001607f1b82811615611f2d5770016a09e667f3bcc908b2fb1366ea957d3e0260801c5b6001607e1b831615611f50577001306fe0a31b7152de8d5a46305c85edec0260801c5b6001607d1b831615611f73577001172b83c7d517adcdf7c8c50eb14a791f0260801c5b6001607c1b831615611f965770010b5586cf9890f6298b92b71842a983630260801c5b6001607b1b831615611fb9577001059b0d31585743ae7c548eb68ca417fd0260801c5b6001607a1b831615611fdc57700102c9a3e778060ee6f7caca4f7a29bde80260801c5b600160791b831615611fff5770010163da9fb33356d84a66ae336dcdfa3f0260801c5b600160781b83161561202257700100b1afa5abcbed6129ab13ec11dc95430260801c5b600160771b8316156120455770010058c86da1c09ea1ff19d294cf2f679b0260801c5b600160761b831615612068577001002c605e2e8cec506d21bfc89a23a00f0260801c5b600160751b83161561208b57700100162f3904051fa128bca9c55c31e5df0260801c5b600160741b8316156120ae577001000b175effdc76ba38e31671ca9397250260801c5b600160731b8316156120d157700100058ba01fb9f96d6cacd4b180917c3d0260801c5b600160721b8316156120f45770010002c5cc37da9491d0985c348c68e7b30260801c5b600160711b831615612117577001000162e525ee054754457d59952920260260801c5b600160701b83161561213a5770010000b17255775c040618bf4a4ade83fc0260801c5b6001606f1b83161561215d577001000058b91b5bc9ae2eed81e9b7d4cfab0260801c5b6001606e1b83161561218057700100002c5c89d5ec6ca4d7c8acc017b7c90260801c5b6001606d1b8316156121a35770010000162e43f4f831060e02d839a9d16d0260801c5b6001606c1b8316156121c657700100000b1721bcfc99d9f890ea069117630260801c5b6001606b1b8316156121e95770010000058b90cf1e6d97f9ca14dbcc16280260801c5b6001606a1b83161561220c577001000002c5c863b73f016468f6bac5ca2b0260801c5b600160691b83161561222f57700100000162e430e5a18f6119e3c02282a50260801c5b600160681b831615612252577001000000b1721835514b86e6d96efd1bfe0260801c5b600160671b83161561227557700100000058b90c0b48c6be5df846c5b2ef0260801c5b600160661b8316156122985770010000002c5c8601cc6b9e94213c72737a0260801c5b600160651b8316156122bb577001000000162e42fff037df38aa2b219f060260801c5b600160641b8316156122de5770010000000b17217fba9c739aa5819f44f90260801c5b600160631b831615612301577001000000058b90bfcdee5acd3c1cedc8230260801c5b600160621b83161561232457700100000002c5c85fe31f35a6a30da1be500260801c5b600160611b8316156123475770010000000162e42ff0999ce3541b9fffcf0260801c5b600160601b83161561236a57700100000000b17217f80f4ef5aadda455540260801c5b6001605f1b83161561238d5770010000000058b90bfbf8479bd5a81b51ad0260801c5b6001605e1b8316156123b0577001000000002c5c85fdf84bd62ae30a74cc0260801c5b6001605d1b8316156123d357700100000000162e42fefb2fed257559bdaa0260801c5b6001605c1b8316156123f6577001000000000b17217f7d5a7716bba4a9ae0260801c5b6001605b1b83161561241957700100000000058b90bfbe9ddbac5e109cce0260801c5b6001605a1b83161561243c5770010000000002c5c85fdf4b15de6f17eb0d0260801c5b600160591b83161561245f577001000000000162e42fefa494f1478fde050260801c5b600160581b8316156124825770010000000000b17217f7d20cf927c8e94c0260801c5b600160571b8316156124a5577001000000000058b90bfbe8f71cb4e4b33d0260801c5b600160561b8316156124c857700100000000002c5c85fdf477b662b269450260801c5b600160551b8316156124eb5770010000000000162e42fefa3ae53369388c0260801c5b600160541b83161561250e57700100000000000b17217f7d1d351a389d400260801c5b600160531b8316156125315770010000000000058b90bfbe8e8b2d3d4ede0260801c5b600160521b831615612554577001000000000002c5c85fdf4741bea6e77e0260801c5b600160511b83161561257757700100000000000162e42fefa39fe95583c20260801c5b600160501b83161561259a577001000000000000b17217f7d1cfb72b45e10260801c5b69800000000000000000008316156125c357700100000000000058b90bfbe8e7cc35c3f00260801c5b69400000000000000000008316156125ec5770010000000000002c5c85fdf473e242ea380260801c5b6920000000000000000000831615612615577001000000000000162e42fefa39f02b772c0260801c5b691000000000000000000083161561263e5770010000000000000b17217f7d1cf7d83c1a0260801c5b6908000000000000000000831615612667577001000000000000058b90bfbe8e7bdcbe2e0260801c5b690400000000000000000083161561269057700100000000000002c5c85fdf473dea871f0260801c5b69020000000000000000008316156126b95770010000000000000162e42fefa39ef44d910260801c5b69010000000000000000008316156126e257700100000000000000b17217f7d1cf79e9490260801c5b6880000000000000000083161561270a5770010000000000000058b90bfbe8e7bce5440260801c5b68400000000000000000831615612732577001000000000000002c5c85fdf473de6eca0260801c5b6820000000000000000083161561275a57700100000000000000162e42fefa39ef366f0260801c5b68100000000000000000831615612782577001000000000000000b17217f7d1cf79afa0260801c5b680800000000000000008316156127aa57700100000000000000058b90bfbe8e7bcd6d0260801c5b680400000000000000008316156127d25770010000000000000002c5c85fdf473de6b20260801c5b680200000000000000008316156127fa577001000000000000000162e42fefa39ef3580260801c5b600160401b83161561281d5770010000000000000000b17217f7d1cf79ab0260801c5b678000000000000000831615612844577001000000000000000058b90bfbe8e7bcd50260801c5b67400000000000000083161561286b57700100000000000000002c5c85fdf473de6a0260801c5b6720000000000000008316156128925770010000000000000000162e42fefa39ef340260801c5b6710000000000000008316156128b957700100000000000000000b17217f7d1cf7990260801c5b6708000000000000008316156128e05770010000000000000000058b90bfbe8e7bcc0260801c5b670400000000000000831615612907577001000000000000000002c5c85fdf473de50260801c5b67020000000000000083161561292e57700100000000000000000162e42fefa39ef20260801c5b670100000000000000831615612955577001000000000000000000b17217f7d1cf780260801c5b668000000000000083161561297b57700100000000000000000058b90bfbe8e7bb0260801c5b66400000000000008316156129a15770010000000000000000002c5c85fdf473dd0260801c5b66200000000000008316156129c7577001000000000000000000162e42fefa39ee0260801c5b66100000000000008316156129ed5770010000000000000000000b17217f7d1cf60260801c5b6608000000000000831615612a13577001000000000000000000058b90bfbe8e7a0260801c5b6604000000000000831615612a3957700100000000000000000002c5c85fdf473c0260801c5b6602000000000000831615612a5f5770010000000000000000000162e42fefa39d0260801c5b6601000000000000831615612a8557700100000000000000000000b17217f7d1ce0260801c5b65800000000000831615612aaa5770010000000000000000000058b90bfbe8e60260801c5b65400000000000831615612acf577001000000000000000000002c5c85fdf4720260801c5b65200000000000831615612af457700100000000000000000000162e42fefa380260801c5b65100000000000831615612b19577001000000000000000000000b17217f7d1b0260801c5b65080000000000831615612b3e57700100000000000000000000058b90bfbe8d0260801c5b65040000000000831615612b635770010000000000000000000002c5c85fdf460260801c5b65020000000000831615612b88577001000000000000000000000162e42fefa20260801c5b65010000000000831615612bad5770010000000000000000000000b17217f7d00260801c5b648000000000831615612bd1577001000000000000000000000058b90bfbe70260801c5b644000000000831615612bf557700100000000000000000000002c5c85fdf30260801c5b642000000000831615612c195770010000000000000000000000162e42fef90260801c5b641000000000831615612c3d57700100000000000000000000000b17217f7c0260801c5b640800000000831615612c615770010000000000000000000000058b90bfbd0260801c5b640400000000831615612c85577001000000000000000000000002c5c85fde0260801c5b640200000000831615612ca957700100000000000000000000000162e42fee0260801c5b640100000000831615612ccd577001000000000000000000000000b17217f60260801c5b6380000000831615612cf057700100000000000000000000000058b90bfa0260801c5b6340000000831615612d135770010000000000000000000000002c5c85fc0260801c5b6320000000831615612d36577001000000000000000000000000162e42fd0260801c5b6310000000831615612d595770010000000000000000000000000b17217e0260801c5b6308000000831615612d7c577001000000000000000000000000058b90be0260801c5b6304000000831615612d9f57700100000000000000000000000002c5c85e0260801c5b6302000000831615612dc25770010000000000000000000000000162e42e0260801c5b6301000000831615612de557700100000000000000000000000000b172160260801c5b62800000831615612e075770010000000000000000000000000058b90a0260801c5b62400000831615612e29577001000000000000000000000000002c5c840260801c5b62200000831615612e4b57700100000000000000000000000000162e410260801c5b62100000831615612e6d577001000000000000000000000000000b17200260801c5b62080000831615612e8f57700100000000000000000000000000058b8f0260801c5b62040000831615612eb15770010000000000000000000000000002c5c70260801c5b62020000831615612ed3577001000000000000000000000000000162e30260801c5b62010000831615612ef55770010000000000000000000000000000b1710260801c5b618000831615612f16577001000000000000000000000000000058b80260801c5b614000831615612f3757700100000000000000000000000000002c5b0260801c5b612000831615612f585770010000000000000000000000000000162d0260801c5b611000831615612f7957700100000000000000000000000000000b160260801c5b610800831615612f9a5770010000000000000000000000000000058a0260801c5b610400831615612fbb577001000000000000000000000000000002c40260801c5b610200831615612fdc577001000000000000000000000000000001610260801c5b610100831615612ffd577001000000000000000000000000000000b00260801c5b608083161561301d577001000000000000000000000000000000570260801c5b604083161561303d5770010000000000000000000000000000002b0260801c5b602083161561305d577001000000000000000000000000000000150260801c5b601083161561307d5770010000000000000000000000000000000a0260801c5b600883161561309d577001000000000000000000000000000000040260801c5b60048316156130bd577001000000000000000000000000000000010260801c5b846130de57600f81901c6001600160701b03169050613fff8201915061310d565b613ffe821161310357600f81901c6001600160701b0316905081613fff03915061310d565b600091613fee19011c5b60709190911b1760801b95945050505050565b600080821161312e57600080fd5b6000600160801b831061314357608092831c92015b600160401b831061315657604092831c92015b640100000000831061316a57602092831c92015b62010000831061317c57601092831c92015b610100831061318d57600892831c92015b6010831061319d57600492831c92015b600483106131ad57600292831c92015b600283106104c15760010192915050565b60006104c1610ca6836f1fffb8aa3b295c17f0bbbe87fed0691d60811b611514565b80356001600160801b0319811681146111f457600080fd5b60006020828403121561320a57600080fd5b6104be826131e0565b6000806040838503121561322657600080fd5b61322f836131e0565b915061323d602084016131e0565b90509250929050565b60008060006060848603121561325b57600080fd5b613264846131e0565b925060208401358060000b811461327a57600080fd5b9150613288604085016131e0565b90509250925092565b600080604083850312156132a457600080fd5b6132ad836131e0565b946020939093013593505050565b600080604083850312156132ce57600080fd5b50508035926020909101359150565b600061018082840312156132f057600080fd5b50919050565b60006020828403121561330857600080fd5b5035919050565b6000806000806080858703121561332557600080fd5b84359350613335602086016131e0565b9250613343604086016131e0565b9150613351606086016131e0565b905092959194509250565b60008060008060008060c0878903121561337557600080fd5b863595506020870135945061338c604088016131e0565b935060608701359250608087013591506133a860a088016131e0565b90509295509295509295565b6000806000606084860312156133c957600080fd5b505081359360208301359350604090920135919050565b600080600080608085870312156133f657600080fd5b5050823594602084013594506040840135936060013592509050565b600080600080600060a0868803121561342a57600080fd5b505083359560208501359550604085013594606081013594506080013592509050565b60008219821115613460576134606135be565b500190565b60008261348257634e487b7160e01b600052601260045260246000fd5b500490565b600181815b808511156134c25781600019048211156134a8576134a86135be565b808516156134b557918102915b93841c939080029061348c565b509250929050565b60006104be83836000826134e0575060016104c1565b816134ed575060006104c1565b8160018114613503576002811461350d57613529565b60019150506104c1565b60ff84111561351e5761351e6135be565b50506001821b6104c1565b5060208310610133831016604e8410600b841016171561354c575081810a6104c1565b6135568383613487565b806000190482111561356a5761356a6135be565b029392505050565b600081600019048311821515161561358c5761358c6135be565b500290565b6000828210156135a3576135a36135be565b500390565b634e487b7160e01b600052600160045260246000fd5b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052601260045260246000fdfea26469706673582212201567fd47f28e6e1d80041133b9f2acc826a94a93c51e4304a7efe1e7b8261ea464736f6c63430008070033",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600436106101ce5760003560e01c8063aeb64d7d11610103578063dc35bc13116100a1578063e45639451161007b578063e456394514610466578063fc31158114610479578063fea3de331461048c578063ff9afe871461049f57600080fd5b8063dc35bc1314610418578063debb52df14610440578063dfdbe4da1461045357600080fd5b8063bf36f0e9116100dd578063bf36f0e9146103d3578063c2ee3a08146103e6578063c3ff8091146103f2578063cff700011461040557600080fd5b8063aeb64d7d1461037a578063b6b2f9f61461038d578063b89bf2ef146103a057600080fd5b8063664808a8116101705780639eb17fa31161014a5780639eb17fa3146102ec578063a818c0d214610341578063aacf0ecb14610354578063ab41556f1461036757600080fd5b8063664808a81461028c57806381a799db1461029b578063839dff3d146102be57600080fd5b8063202f1257116101ac578063202f125714610240578063422051e71461025357806345e7ef9b146102665780635cf4ee911461027957600080fd5b80630417cf8e146101d35780630e8418dd146101ee5780631842c9d81461021a575b600080fd5b6101db601281565b6040519081526020015b60405180910390f35b6102016101fc366004613213565b6104b2565b6040516001600160801b031990911681526020016101e5565b61022d610228366004613213565b6104c7565b60405160009190910b81526020016101e5565b61020161024e3660046132bb565b6104d3565b610201610261366004613291565b6104ef565b610201610274366004613213565b610503565b6102016102873660046132bb565b61050f565b6101db670de0b6b3a764000081565b6102ae6102a93660046133e0565b610537565b60405190151581526020016101e5565b6102d16102cc36600461330f565b61055b565b604080519384526020840192909252908201526060016101e5565b6102ff6102fa3660046132dd565b6105ae565b6040516101e59190600060a082019050825182526020830151602083015260408301516040830152606083015160608301526080830151608083015292915050565b6101db61034f366004613291565b6108ed565b6101db610362366004613291565b610912565b6101db6103753660046133e0565b610934565b6101db6103883660046131f8565b610988565b61020161039b366004613213565b610993565b6103b36103ae36600461335c565b61099f565b6040805194855260208501939093529183015260608201526080016101e5565b6101db6103e13660046132bb565b610c50565b610201613fff60f01b81565b610201610400366004613246565b610c75565b6102016104133660046132bb565b610cb5565b61042b6104263660046133b4565b610cc4565b604080519283526020830191909152016101e5565b6101db61044e3660046133e0565b610d1d565b6102016104613660046132f6565b610d5c565b6101db610474366004613291565b610d67565b6101db610487366004613291565b610e1e565b6101db61049a3660046133b4565b610ed0565b6101db6104ad366004613412565b610f1c565b60006104be838361102d565b90505b92915050565b60006104be838361103f565b60006104be6104e184611166565b6104ea84611166565b6111f9565b60006104be836104fe846114b0565b611514565b60006104be8383611514565b6000816105225750613fff60f01b6104c1565b6104be61052e846114b0565b6104ea846114b0565b60008482610545858761344d565b61054f9190613591565b1190505b949350505050565b60008060008061056b8789610e1e565b905060006105798783610912565b90506105858183613591565b915060006105938784610912565b905061059f8184613591565b9a919950975095505050505050565b6105e06040518060a0016040528060008152602001600081526020016000815260200160008152602001600081525090565b60006040518060a00160405280600081526020016000815260200160008152602001600081526020016000815250905082606001358360800135106106255792915050565b600080610140850135156106a95760008061067161014088013561064f60408a0160208b016131f8565b6106616101808b016101608c016131f8565b6102cc60608c0160408d016131f8565b6060880180519397509194509250839161068c90839061344d565b9052506040850180518291906106a390839061344d565b90525050505b61012085013515610754576106cf6106c460208701876131f8565b866101200135610e1e565b905060006106ee6106e8610180880161016089016131f8565b83610912565b90506106fa8183613591565b915060006107176107116060890160408a016131f8565b84610912565b90506107238184613591565b92508185604001818151610737919061344d565b90525060608501805182919061074e90839061344d565b90525050505b60008560a0013511806107675750600082115b1561079d5761078a61077c60208701876131f8565b6104748460a089013561344d565b8351849061079990839061344d565b9052505b60008560e0013511806107b05750600081115b156107eb576107d66107c860408701602088016131f8565b6104748360e089013561344d565b836020018181516107e7919061344d565b9052505b60c08501351561086557600061081161080760208801886131f8565b8760c00135610e1e565b9050600061082a6106e861018089016101608a016131f8565b9050808560400181815161083e919061344d565b90525061084b8183613591565b9150818560800181815161085f919061344d565b90525050505b610100850135156108e457600061089061088560408801602089016131f8565b876101000135610e1e565b905060006108a96106e861018089016101608a016131f8565b905080856060018181516108bd919061344d565b9052506108ca8183613591565b915081856080018181516108de919061344d565b90525050505b50909392505050565b60006104be61090d610904613fff60f01b8661102d565b6104fe856114b0565b61176f565b6000670de0b6b3a764000061092a61090d85856104ef565b6104be9190613465565b600082158061094a5750610948828661344d565b155b80610953575083155b1561095f575082610553565b828461096b848861344d565b6109759190613572565b61097f9190613465565b95945050505050565b60006104c18261176f565b60006104be83836117f2565b60008060008060006040518060c001604052808981526020018881526020018c81526020018b81526020018a6001600160801b0319168152602001876001600160801b03191681525090506000670de0b6b3a7640000610a0a6103888460a0015185604001516104ef565b610a149190613465565b90506000670de0b6b3a7640000610a366103888560a0015186606001516104ef565b610a409190613465565b90508083606001818151610a549190613591565b905250604083018051839190610a6b908390613591565b90525060408301516060840151600091610a849161344d565b90508a8a12158015610a9a575060008460600151115b15610b22576000610ab3856000015186602001516104d3565b90506000610ac18e83611bb2565b9050610adc61090d610ad688606001516114b0565b83611514565b86604001818151610aed919061344d565b9052506060860151610b159061090d90610b06906114b0565b6104fe613fff60f01b8561102d565b606087015250610ba39050565b8a8a128015610b35575060008460400151115b15610ba3576000610b4e856020015186600001516104d3565b90506000610b5c8e83611bb2565b9050610b7161090d610ad688604001516114b0565b86606001818151610b82919061344d565b9052506040860151610b9b9061090d90610b06906114b0565b604087015250505b83606001518460400151610bb7919061344d565b811115610c30578a8a1315610bfd5783606001518460400151610bda919061344d565b610be49082613591565b84604001818151610bf5919061344d565b905250610c30565b83606001518460400151610c11919061344d565b610c1b9082613591565b84606001818151610c2c919061344d565b9052505b506040830151606090930151929d929c50909a5098509650505050505050565b600080610c5e836012613591565b610c6990600a6134ca565b90506105538185613465565b6000610cab610ca6836104fe60008760000b12610ca057610c9b613fff60f01b896111f9565b611c1e565b87611c1e565b611dce565b90505b9392505050565b600081610522575060006104c1565b60008080610cd685610413868261344d565b90506000610ce761038883896104ef565b90506000610cf58288613591565b90506000610d03838a613591565b610d0d9088613591565b9199919850909650505050505050565b6000821580610d335750610d31828661344d565b155b80610d3c575083155b15610d48575082610553565b610d52828661344d565b6109758585613572565b60006104c1826114b0565b60006001600160801b03198316610db25760405162461bcd60e51b815260206004820152600a60248201526907072696365203d3d20360b41b60448201526064015b60405180910390fd5b6001600160801b03198316600160ff1b1415610e095760405162461bcd60e51b81526020600482015260166024820152757072696365203d3d206e65676174697665207a65726f60501b6044820152606401610da9565b6104be61090d610e18846114b0565b856111f9565b60006001600160801b03198316610e645760405162461bcd60e51b815260206004820152600a60248201526907072696365203d3d20360b41b6044820152606401610da9565b6001600160801b03198316600160ff1b1415610ebb5760405162461bcd60e51b81526020600482015260166024820152757072696365203d3d206e65676174697665207a65726f60501b6044820152606401610da9565b6104be61090d610eca846114b0565b85611514565b600081610edf57506000610cae565b6000610ef6610eed866114b0565b6104fe866114b0565b90506000610f07826104ea866114b0565b9050610f1281610988565b9695505050505050565b600085851115610f665760405162461bcd60e51b81526020600482015260156024820152741d1a5b595cdd185b5c081a5b881d1a19481c185cdd605a1b6044820152606401610da9565b828411610ffc57610f7986868587610537565b15610f8557508061097f565b600083610f928789613591565b610f9c9190613465565b905060008585610fad84600161344d565b610fb79190613572565b610fc1908961344d565b610fcb9190613591565b9050808810610ff257610fde828561344d565b610fe990600161344d565b9250505061097f565b610fe9828561344d565b6000611008858861344d565b90506000846110178884613591565b6110219190613465565b9050610fe9818561344d565b60006104be83600160ff1b84186117f2565b600060016001607f1b03608084901c16617fff60701b81111561106157600080fd5b60016001607f1b03608084901c16617fff60701b81111561108157600080fd5b6001600160801b03198581169085161415806110aa5750617fff60701b826001600160801b0316105b6110b357600080fd5b6001600160801b031985811690851614156110d3576000925050506104c1565b6001607f1b608086811c82118015929187901c91909110159061112557801561111657826001600160801b0316846001600160801b03161161111657600161111a565b6000195b9450505050506104c1565b80156111385760019450505050506104c1565b826001600160801b0316846001600160801b0316116111595760001961111a565b60019450505050506104c1565b60008161117557506000919050565b60008083136111875782600003611189565b825b9050600061119682613120565b905060708110156111af578060700382901b91506111c2565b60708111156111c2576070810382901c91505b6001600160701b03909116613fff820160701b179060008412156111ea576001607f1b821791505b5060801b92915050565b919050565b6000617fff60f084811c8216919084901c81169082141561123f5780617fff141561122e575061ffff60ef1b91506104c19050565b505050600160ff1b811682186104c1565b80617fff1415611283576dffffffffffffffffffffffffffff60801b841615611272575061ffff60ef1b91506104c19050565b505050808218600160ff1b166104c1565b600160801b600160ff1b0384166112cd57600160801b600160ff1b0385166112b5575061ffff60ef1b91506104c19050565b505050808218600160ff1b16617fff60f01b176104c1565b6001600160701b03608085901c16816112e957600191506112f0565b600160701b175b6001600160701b03608087901c168361132f57801561132a57600061131482613120565b6001955060e20393840160711901939190911b90505b611339565b600160701b1760721b5b818181611348576113486135d4565b0490508061137457600160ff1b8787181661136457600061111a565b600160ff1b9450505050506104c1565b6001606c1b811015611388576113886135a8565b6000600160731b8210156113c757600160721b8210156113bc57600160711b8210156113b55760706113bf565b60716113bf565b60725b60ff166113d0565b6113d082613120565b9050836140710181860111156113ee57617fff945060009150611481565b83818601613ffc011015611409576000945060009150611481565b83818601613f8c011015611456578385613ffc011115611434578385613ffc010382901b915061144d565b8385613ffc01101561144d57613ffc8585030382901c91505b60009450611481565b6070811115611469576070810382901c91505b6001600160701b038216915083818601613f8d010394505b81607086901b888a186001607f1b60801b1660801c6001600160801b0316171760801b955050505050506104c1565b6000816114bf57506000919050565b8160006114cb82613120565b905060708110156114e4578060700382901b91506114f7565b60708111156114f7576070810382901c91505b613fff0160701b6001600160701b03919091161760801b92915050565b6000617fff60f084811c8216919084901c8116908214156115b35780617fff1415611592576001600160801b0319858116908516141561155f57505050600160ff1b811682186104c1565b600160ff1b6001600160801b0319868618161415611582575050508181176104c1565b5061ffff60ef1b91506104c19050565b600160801b600160ff1b03841661122e575061ffff60ef1b91506104c19050565b80617fff14156115ef57600160801b600160ff1b0385166115de575061ffff60ef1b91506104c19050565b505050600160ff1b821681186104c1565b6001600160701b03608086901c168261160b5760019250611612565b600160701b175b6001600160701b03608086901c168261162e5760019250611635565b600160701b175b908102908161165257600160ff1b8787181661136457600061111a565b928201926000600160e11b83101561168557600160e01b83101561167e5761167983613120565b611688565b60e0611688565b60e15b905061407081860110156116a3576000945060009250611740565b6140e081860110156116e6576140708510156116c857846140700383901c92506116dd565b6140708511156116dd57614070850383901b92505b60009450611740565b61c0dd818601111561170057617fff945060009250611740565b6070811115611717576070810383901c925061172a565b607081101561172a578060700383901b92505b6001600160701b03831692506140df8186010394505b82607086901b888a186001607f1b60801b1660801c6001600160801b0316171760801b955050505050506104c1565b6000617fff60f083901c16613fff81101561178d5750600092915050565b6001607f1b608084901c106117a157600080fd5b6140fe8111156117b057600080fd5b600160701b6001600160701b03608085901c161761406f8210156117da5761406f8290031c610cae565b61406f821115610cae5761406e1982011b9392505050565b6000617fff60f084811c8216919084901c8116908214156118405780617fff1415611836576001600160801b031985811690851614156115825784925050506104c1565b84925050506104c1565b80617fff14156118545783925050506104c1565b6001607f1b608086901c90811015906001600160701b03168361187a5760019350611881565b600160701b175b6001607f1b608087901c90811015906001600160701b0316846118a757600194506118ae565b600160701b175b826118de576001600160801b03198816600160ff1b146118ce57876118d1565b60005b96505050505050506104c1565b806118fe576001600160801b03198916600160ff1b146118ce57886118d1565b8486038415158315151415611a0957607081131561192557899750505050505050506104c1565b60008113156119375790811c90611966565b606f1981121561195057889750505050505050506104c1565b6000811215611966578060000384901c93508596505b92810192600160711b8410611981576001968701969390931c925b86617fff14156119b3578461199b57617fff60f01b6119a5565b6001600160f01b03195b9750505050505050506104c1565b600160701b8410156119c857600096506119d5565b6001600160701b03841693505b83607088901b866119e75760006119ed565b6001607f1b5b6001600160801b0316171760801b9750505050505050506104c1565b6000811315611a2457600184901b9350600187039650611a3b565b6000811215611a3b57600182901b91506001860396505b6070811315611a4d5760019150611a9a565b6001811315611a6a576001810360018303901c6001019150611a9a565b606f19811215611a7d5760019350611a9a565b600019811215611a9a576001816000030360018503901c60010193505b818410611aab578184039350611ab4565b83820393508294505b83611aca5750600096506104c195505050505050565b6000611ad585613120565b90508060711415611afb57600185901c6001600160701b03169450600188019750611b4a565b6070811015611b3d57607081900380891115611b2a578086901b6001600160701b031695508089039850611b37565b600098600019019590951b945b50611b4a565b6001600160701b03851694505b87617fff1415611b7d5785611b6457617fff60f01b611b6e565b6001600160f01b03195b985050505050505050506104c1565b84607089901b87611b8f576000611b95565b6001607f1b5b6001600160801b0316171760801b985050505050505050506104c1565b600080611bc3610eca600119611166565b9050611bd8816104fe613fff60f01b8661102d565b9050611bf1613fff60f01b611bec836131be565b6117f2565b90506000611c04613fff60f01b806117f2565b905061097f611c1382846111f9565b613fff60f01b61102d565b60006001607f1b608083901c1115611c3c575061ffff60ef1b919050565b613fff60f01b6001600160801b031983161415611c5b57506000919050565b617fff60f083901c811690811415611c74575090919050565b6001600160701b03608084901c1681611c905760019150611c97565b600160701b175b80611cad57506001600160f01b03199392505050565b600061406f81613fff8510611cd35750600f9290921b9160009150613ffe198401611d12565b60019250600160701b8410611cf55784613ffe039050600f84901b9350611d12565b6000611d0085613120565b607f8190039590951b9461406d039150505b836001607f1b1415611d46578215611d28576001015b6000611d3382613120565b60700392839003929190911b9050611d94565b600083611d54576000611d57565b60015b60ff1690505b600160701b821015611d925793800260ff81901c607f81019190911c94600019939093019260019290921b9082180190611d5d565b505b806001600160701b0316607083901b84611daf576000611db5565b6001607f1b5b6001600160801b0316171760801b979650505050505050565b60006001607f1b608083901c90811190617fff60f085901c8116916001600160701b03169082148015611e0057508015155b15611e14575061ffff60ef1b949350505050565b61400d821115611e395782611e2e57617fff60f01b61097f565b600095945050505050565b613f7f821015611e525750613fff60f01b949350505050565b81611e605760019150611e67565b600160701b175b613fef821115611e7d57613fee1982011b611e8f565b613fef821015611e8f57613fef8290031c5b828015611ea0575061203760811b81115b15611eb057506000949350505050565b82158015611ecf5750713fffffffffffffffffffffffffffffffffff81115b15611ee35750617fff60f01b949350505050565b6001600160801b0381169060801c838015611efd57508115155b15611f09579019906001015b6001607f1b82811615611f2d5770016a09e667f3bcc908b2fb1366ea957d3e0260801c5b6001607e1b831615611f50577001306fe0a31b7152de8d5a46305c85edec0260801c5b6001607d1b831615611f73577001172b83c7d517adcdf7c8c50eb14a791f0260801c5b6001607c1b831615611f965770010b5586cf9890f6298b92b71842a983630260801c5b6001607b1b831615611fb9577001059b0d31585743ae7c548eb68ca417fd0260801c5b6001607a1b831615611fdc57700102c9a3e778060ee6f7caca4f7a29bde80260801c5b600160791b831615611fff5770010163da9fb33356d84a66ae336dcdfa3f0260801c5b600160781b83161561202257700100b1afa5abcbed6129ab13ec11dc95430260801c5b600160771b8316156120455770010058c86da1c09ea1ff19d294cf2f679b0260801c5b600160761b831615612068577001002c605e2e8cec506d21bfc89a23a00f0260801c5b600160751b83161561208b57700100162f3904051fa128bca9c55c31e5df0260801c5b600160741b8316156120ae577001000b175effdc76ba38e31671ca9397250260801c5b600160731b8316156120d157700100058ba01fb9f96d6cacd4b180917c3d0260801c5b600160721b8316156120f45770010002c5cc37da9491d0985c348c68e7b30260801c5b600160711b831615612117577001000162e525ee054754457d59952920260260801c5b600160701b83161561213a5770010000b17255775c040618bf4a4ade83fc0260801c5b6001606f1b83161561215d577001000058b91b5bc9ae2eed81e9b7d4cfab0260801c5b6001606e1b83161561218057700100002c5c89d5ec6ca4d7c8acc017b7c90260801c5b6001606d1b8316156121a35770010000162e43f4f831060e02d839a9d16d0260801c5b6001606c1b8316156121c657700100000b1721bcfc99d9f890ea069117630260801c5b6001606b1b8316156121e95770010000058b90cf1e6d97f9ca14dbcc16280260801c5b6001606a1b83161561220c577001000002c5c863b73f016468f6bac5ca2b0260801c5b600160691b83161561222f57700100000162e430e5a18f6119e3c02282a50260801c5b600160681b831615612252577001000000b1721835514b86e6d96efd1bfe0260801c5b600160671b83161561227557700100000058b90c0b48c6be5df846c5b2ef0260801c5b600160661b8316156122985770010000002c5c8601cc6b9e94213c72737a0260801c5b600160651b8316156122bb577001000000162e42fff037df38aa2b219f060260801c5b600160641b8316156122de5770010000000b17217fba9c739aa5819f44f90260801c5b600160631b831615612301577001000000058b90bfcdee5acd3c1cedc8230260801c5b600160621b83161561232457700100000002c5c85fe31f35a6a30da1be500260801c5b600160611b8316156123475770010000000162e42ff0999ce3541b9fffcf0260801c5b600160601b83161561236a57700100000000b17217f80f4ef5aadda455540260801c5b6001605f1b83161561238d5770010000000058b90bfbf8479bd5a81b51ad0260801c5b6001605e1b8316156123b0577001000000002c5c85fdf84bd62ae30a74cc0260801c5b6001605d1b8316156123d357700100000000162e42fefb2fed257559bdaa0260801c5b6001605c1b8316156123f6577001000000000b17217f7d5a7716bba4a9ae0260801c5b6001605b1b83161561241957700100000000058b90bfbe9ddbac5e109cce0260801c5b6001605a1b83161561243c5770010000000002c5c85fdf4b15de6f17eb0d0260801c5b600160591b83161561245f577001000000000162e42fefa494f1478fde050260801c5b600160581b8316156124825770010000000000b17217f7d20cf927c8e94c0260801c5b600160571b8316156124a5577001000000000058b90bfbe8f71cb4e4b33d0260801c5b600160561b8316156124c857700100000000002c5c85fdf477b662b269450260801c5b600160551b8316156124eb5770010000000000162e42fefa3ae53369388c0260801c5b600160541b83161561250e57700100000000000b17217f7d1d351a389d400260801c5b600160531b8316156125315770010000000000058b90bfbe8e8b2d3d4ede0260801c5b600160521b831615612554577001000000000002c5c85fdf4741bea6e77e0260801c5b600160511b83161561257757700100000000000162e42fefa39fe95583c20260801c5b600160501b83161561259a577001000000000000b17217f7d1cfb72b45e10260801c5b69800000000000000000008316156125c357700100000000000058b90bfbe8e7cc35c3f00260801c5b69400000000000000000008316156125ec5770010000000000002c5c85fdf473e242ea380260801c5b6920000000000000000000831615612615577001000000000000162e42fefa39f02b772c0260801c5b691000000000000000000083161561263e5770010000000000000b17217f7d1cf7d83c1a0260801c5b6908000000000000000000831615612667577001000000000000058b90bfbe8e7bdcbe2e0260801c5b690400000000000000000083161561269057700100000000000002c5c85fdf473dea871f0260801c5b69020000000000000000008316156126b95770010000000000000162e42fefa39ef44d910260801c5b69010000000000000000008316156126e257700100000000000000b17217f7d1cf79e9490260801c5b6880000000000000000083161561270a5770010000000000000058b90bfbe8e7bce5440260801c5b68400000000000000000831615612732577001000000000000002c5c85fdf473de6eca0260801c5b6820000000000000000083161561275a57700100000000000000162e42fefa39ef366f0260801c5b68100000000000000000831615612782577001000000000000000b17217f7d1cf79afa0260801c5b680800000000000000008316156127aa57700100000000000000058b90bfbe8e7bcd6d0260801c5b680400000000000000008316156127d25770010000000000000002c5c85fdf473de6b20260801c5b680200000000000000008316156127fa577001000000000000000162e42fefa39ef3580260801c5b600160401b83161561281d5770010000000000000000b17217f7d1cf79ab0260801c5b678000000000000000831615612844577001000000000000000058b90bfbe8e7bcd50260801c5b67400000000000000083161561286b57700100000000000000002c5c85fdf473de6a0260801c5b6720000000000000008316156128925770010000000000000000162e42fefa39ef340260801c5b6710000000000000008316156128b957700100000000000000000b17217f7d1cf7990260801c5b6708000000000000008316156128e05770010000000000000000058b90bfbe8e7bcc0260801c5b670400000000000000831615612907577001000000000000000002c5c85fdf473de50260801c5b67020000000000000083161561292e57700100000000000000000162e42fefa39ef20260801c5b670100000000000000831615612955577001000000000000000000b17217f7d1cf780260801c5b668000000000000083161561297b57700100000000000000000058b90bfbe8e7bb0260801c5b66400000000000008316156129a15770010000000000000000002c5c85fdf473dd0260801c5b66200000000000008316156129c7577001000000000000000000162e42fefa39ee0260801c5b66100000000000008316156129ed5770010000000000000000000b17217f7d1cf60260801c5b6608000000000000831615612a13577001000000000000000000058b90bfbe8e7a0260801c5b6604000000000000831615612a3957700100000000000000000002c5c85fdf473c0260801c5b6602000000000000831615612a5f5770010000000000000000000162e42fefa39d0260801c5b6601000000000000831615612a8557700100000000000000000000b17217f7d1ce0260801c5b65800000000000831615612aaa5770010000000000000000000058b90bfbe8e60260801c5b65400000000000831615612acf577001000000000000000000002c5c85fdf4720260801c5b65200000000000831615612af457700100000000000000000000162e42fefa380260801c5b65100000000000831615612b19577001000000000000000000000b17217f7d1b0260801c5b65080000000000831615612b3e57700100000000000000000000058b90bfbe8d0260801c5b65040000000000831615612b635770010000000000000000000002c5c85fdf460260801c5b65020000000000831615612b88577001000000000000000000000162e42fefa20260801c5b65010000000000831615612bad5770010000000000000000000000b17217f7d00260801c5b648000000000831615612bd1577001000000000000000000000058b90bfbe70260801c5b644000000000831615612bf557700100000000000000000000002c5c85fdf30260801c5b642000000000831615612c195770010000000000000000000000162e42fef90260801c5b641000000000831615612c3d57700100000000000000000000000b17217f7c0260801c5b640800000000831615612c615770010000000000000000000000058b90bfbd0260801c5b640400000000831615612c85577001000000000000000000000002c5c85fde0260801c5b640200000000831615612ca957700100000000000000000000000162e42fee0260801c5b640100000000831615612ccd577001000000000000000000000000b17217f60260801c5b6380000000831615612cf057700100000000000000000000000058b90bfa0260801c5b6340000000831615612d135770010000000000000000000000002c5c85fc0260801c5b6320000000831615612d36577001000000000000000000000000162e42fd0260801c5b6310000000831615612d595770010000000000000000000000000b17217e0260801c5b6308000000831615612d7c577001000000000000000000000000058b90be0260801c5b6304000000831615612d9f57700100000000000000000000000002c5c85e0260801c5b6302000000831615612dc25770010000000000000000000000000162e42e0260801c5b6301000000831615612de557700100000000000000000000000000b172160260801c5b62800000831615612e075770010000000000000000000000000058b90a0260801c5b62400000831615612e29577001000000000000000000000000002c5c840260801c5b62200000831615612e4b57700100000000000000000000000000162e410260801c5b62100000831615612e6d577001000000000000000000000000000b17200260801c5b62080000831615612e8f57700100000000000000000000000000058b8f0260801c5b62040000831615612eb15770010000000000000000000000000002c5c70260801c5b62020000831615612ed3577001000000000000000000000000000162e30260801c5b62010000831615612ef55770010000000000000000000000000000b1710260801c5b618000831615612f16577001000000000000000000000000000058b80260801c5b614000831615612f3757700100000000000000000000000000002c5b0260801c5b612000831615612f585770010000000000000000000000000000162d0260801c5b611000831615612f7957700100000000000000000000000000000b160260801c5b610800831615612f9a5770010000000000000000000000000000058a0260801c5b610400831615612fbb577001000000000000000000000000000002c40260801c5b610200831615612fdc577001000000000000000000000000000001610260801c5b610100831615612ffd577001000000000000000000000000000000b00260801c5b608083161561301d577001000000000000000000000000000000570260801c5b604083161561303d5770010000000000000000000000000000002b0260801c5b602083161561305d577001000000000000000000000000000000150260801c5b601083161561307d5770010000000000000000000000000000000a0260801c5b600883161561309d577001000000000000000000000000000000040260801c5b60048316156130bd577001000000000000000000000000000000010260801c5b846130de57600f81901c6001600160701b03169050613fff8201915061310d565b613ffe821161310357600f81901c6001600160701b0316905081613fff03915061310d565b600091613fee19011c5b60709190911b1760801b95945050505050565b600080821161312e57600080fd5b6000600160801b831061314357608092831c92015b600160401b831061315657604092831c92015b640100000000831061316a57602092831c92015b62010000831061317c57601092831c92015b610100831061318d57600892831c92015b6010831061319d57600492831c92015b600483106131ad57600292831c92015b600283106104c15760010192915050565b60006104c1610ca6836f1fffb8aa3b295c17f0bbbe87fed0691d60811b611514565b80356001600160801b0319811681146111f457600080fd5b60006020828403121561320a57600080fd5b6104be826131e0565b6000806040838503121561322657600080fd5b61322f836131e0565b915061323d602084016131e0565b90509250929050565b60008060006060848603121561325b57600080fd5b613264846131e0565b925060208401358060000b811461327a57600080fd5b9150613288604085016131e0565b90509250925092565b600080604083850312156132a457600080fd5b6132ad836131e0565b946020939093013593505050565b600080604083850312156132ce57600080fd5b50508035926020909101359150565b600061018082840312156132f057600080fd5b50919050565b60006020828403121561330857600080fd5b5035919050565b6000806000806080858703121561332557600080fd5b84359350613335602086016131e0565b9250613343604086016131e0565b9150613351606086016131e0565b905092959194509250565b60008060008060008060c0878903121561337557600080fd5b863595506020870135945061338c604088016131e0565b935060608701359250608087013591506133a860a088016131e0565b90509295509295509295565b6000806000606084860312156133c957600080fd5b505081359360208301359350604090920135919050565b600080600080608085870312156133f657600080fd5b5050823594602084013594506040840135936060013592509050565b600080600080600060a0868803121561342a57600080fd5b505083359560208501359550604085013594606081013594506080013592509050565b60008219821115613460576134606135be565b500190565b60008261348257634e487b7160e01b600052601260045260246000fd5b500490565b600181815b808511156134c25781600019048211156134a8576134a86135be565b808516156134b557918102915b93841c939080029061348c565b509250929050565b60006104be83836000826134e0575060016104c1565b816134ed575060006104c1565b8160018114613503576002811461350d57613529565b60019150506104c1565b60ff84111561351e5761351e6135be565b50506001821b6104c1565b5060208310610133831016604e8410600b841016171561354c575081810a6104c1565b6135568383613487565b806000190482111561356a5761356a6135be565b029392505050565b600081600019048311821515161561358c5761358c6135be565b500290565b6000828210156135a3576135a36135be565b500390565b634e487b7160e01b600052600160045260246000fd5b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052601260045260246000fdfea26469706673582212201567fd47f28e6e1d80041133b9f2acc826a94a93c51e4304a7efe1e7b8261ea464736f6c63430008070033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "addBytes(bytes16,bytes16)": {
        "params": {
          "x": "The number to be added with `y`",
          "y": "The number to be added with `x`"
        }
      },
      "appropriateUpdateIntervalId(uint256,uint256,uint256,uint256,uint256)": {
        "details": "Note that the timestamp parameter is required to be >= lastPriceTimestamp",
        "params": {
          "currentUpdateIntervalId": "The current update interval's ID",
          "frontRunningInterval": "The frontrunning interval of a pool - The amount of time before an update interval that you must commit to get included in that update",
          "lastPriceTimestamp": "The timestamp of the last price update",
          "timestamp": "Current block.timestamp",
          "updateInterval": "The frequency of a pool's updates"
        },
        "returns": {
          "_0": "The update interval ID in which a commit being made at time timestamp should be included"
        }
      },
      "calculateValueTransfer(uint256,uint256,bytes16,int256,int256,bytes16)": {
        "details": "This function should be called by the LeveragedPoolThe value transfer is calculated using a sigmoid functionThe sigmoid function used is defined as follows:          when newPrice >= oldPrice              losing_pool_multiplier = 2 / (1 + e^(-2 * L * (1 - (newPrice / oldPrice)))) - 1          when newPrice < oldPrice              losing_pool_multiplier = 2 / (1 + e^(-2 * L * (1 - (oldPrice / newPrice)))) - 1          where              e = euler's number              L = leverage              newPrice = the new oracle price              oldPrice = the previous oracle price",
        "params": {
          "fee": "The pool's annualised protocol fee",
          "leverageAmount": "The leverage of the pool",
          "longBalance": "Settlement token balance on the long side of the pool before the price change",
          "newPrice": "The new price",
          "oldPrice": "The previous price",
          "shortBalance": "Settlement token balance on the short side of the pool before the price change"
        },
        "returns": {
          "_0": "Resulting long balance",
          "_1": "Resulting short balance",
          "_2": "Resulting fees taken from long balance",
          "_3": "Resulting fees taken from short balance"
        }
      },
      "compareDecimals(bytes16,bytes16)": {
        "params": {
          "x": "The first number to compare",
          "y": "The second number to compare"
        },
        "returns": {
          "_0": "-1 if x < y, 0 if x = y, or 1 if x > y"
        }
      },
      "convertDecimalToUInt(bytes16)": {
        "params": {
          "ratio": "The value to convert"
        },
        "returns": {
          "_0": "The converted value"
        }
      },
      "convertUIntToDecimal(uint256)": {
        "params": {
          "amount": "The amount to convert"
        },
        "returns": {
          "_0": "The amount as a IEEE754 quadruple precision number"
        }
      },
      "divInt(int256,int256)": {
        "params": {
          "a": "The dividend",
          "b": "The divisor"
        },
        "returns": {
          "_0": "The quotient"
        }
      },
      "fromWad(uint256,uint256)": {
        "params": {
          "_decimals": "Quantity of decimal places to support",
          "_wadValue": "wad number"
        },
        "returns": {
          "_0": "Converted (non-WAD) value"
        }
      },
      "getBalancesAfterFees(uint256,uint256,uint256)": {
        "details": "Assumes shortBalance + longBalance >= reward",
        "params": {
          "longBalance": "Long balance of the pool",
          "reward": "Amount of keeper reward",
          "shortBalance": "Short balance of the pool"
        },
        "returns": {
          "_0": "shortBalanceAfterFees Short balance of the pool after the keeper reward has been paid",
          "_1": "longBalanceAfterFees Long balance of the pool after the keeper reward has been paid"
        }
      },
      "getBurn(bytes16,uint256)": {
        "details": "amount * price, where amount is in PoolToken and price is in USD/PoolTokenThrows if price is zero, or IEEE754 negative zero`getBurn()`",
        "params": {
          "amount": "Amount of pool tokens being used to burn",
          "price": "Price of a pool token"
        },
        "returns": {
          "_0": "Quantity of settlement tokens to return to the user after `amount` pool tokens are burnt."
        }
      },
      "getLossAmount(bytes16,uint256)": {
        "params": {
          "balance": "The balance of the losing pool",
          "lossMultiplier": "The multiplier to use"
        }
      },
      "getLossMultiplier(bytes16,int8,bytes16)": {
        "params": {
          "direction": "The direction of the change. -1 if it's decreased, 0 if it hasn't changed, and 1 if it's increased",
          "leverage": "The amount of leverage to apply",
          "ratio": "The ratio of new price to old price"
        },
        "returns": {
          "_0": "The multiplier"
        }
      },
      "getMint(bytes16,uint256)": {
        "details": "Throws if price is zero, or IEEE754 negative zero`getMint()`",
        "params": {
          "amount": "Amount of settlement tokens being used to mint",
          "price": "Price of a pool token"
        },
        "returns": {
          "_0": "Quantity of pool tokens to mint"
        }
      },
      "getMintAmount(uint256,uint256,uint256,uint256)": {
        "details": "Calculated as (tokenSupply + shadowBalance) * amountIn / balance",
        "params": {
          "amountIn": "Commitment amount of settlement tokens going into the pool",
          "balance": "Balance of the pool (no. of underlying settlement tokens in pool)",
          "pendingBurnPoolTokens": "Amount of pool tokens being burnt during this update interval",
          "tokenSupply": "Total supply of pool tokens"
        },
        "returns": {
          "_0": "Number of pool tokens to be minted"
        }
      },
      "getPrice(uint256,uint256)": {
        "details": "Divide the side balance by the pool token's total supply",
        "params": {
          "sideBalance": "no. of underlying settlement tokens on that side of the pool",
          "tokenSupply": "Total supply of pool tokens"
        }
      },
      "getRatio(uint256,uint256)": {
        "details": "Rounds any overflow towards 0. If either parameter is zero, the ratio is 0",
        "params": {
          "_denominator": "The \"per part\" side of the equation. If this is zero, the ratio is zero",
          "_numerator": "The \"parts per\" side of the equation. If this is zero, the ratio is zero"
        },
        "returns": {
          "_0": "the ratio, as an ABDKMathQuad number (IEEE 754 quadruple precision floating point)"
        }
      },
      "getUpdatedAggregateBalance(PoolSwapLibrary.UpdateData)": {
        "params": {
          "data": "Information needed for updating the balance including prices and recent commit amounts"
        },
        "returns": {
          "_0": "The UpdateResult struct with the data pertaining to the update of user's aggregate balance"
        }
      },
      "getWithdrawAmountOnBurn(uint256,uint256,uint256,uint256)": {
        "details": "Calculates as `balance * amountIn / (tokenSupply + shadowBalance)",
        "params": {
          "amountIn": "Commitment amount of pool tokens going into the pool",
          "balance": "Balance of the pool (no. of underlying settlement tokens in pool)",
          "pendingBurnPoolTokens": "Amount of pool tokens being burnt during this update interval",
          "tokenSupply": "Total supply of pool tokens"
        },
        "returns": {
          "_0": "Number of settlement tokens to be withdrawn on a burn"
        }
      },
      "isBeforeFrontRunningInterval(uint256,uint256,uint256,uint256)": {
        "params": {
          "frontRunningInterval": "The window of time before a price update in which users can have their commit executed from",
          "lastPriceTimestamp": "The timestamp of the last price update",
          "subjectTime": "The timestamp for which you want to calculate if it was beforeFrontRunningInterval",
          "updateInterval": "The interval between price updates"
        }
      },
      "mintingOrBurningFee(bytes16,uint256)": {
        "params": {
          "amount": "The amount of settlement tokens being committed to mint",
          "feeRate": "PoolCommitter's mintingFee or burningFee - The amount that is extracted from each mint or burn. Given as the decimal * 10 ^ 18. For example, 60% fee is 0.6 * 10 ^ 18 Fees can be 0."
        }
      },
      "mulFraction(uint256,uint256,uint256)": {
        "params": {
          "denominator": "The denominator of the fraction being multipled with `number`",
          "number": "The number with which the fraction calculated from `numerator` and `denominator` will be multiplied",
          "numerator": "The numerator of the fraction being multipled with `number`"
        },
        "returns": {
          "_0": "The result of multiplying number with numerator/denominator, as an integer"
        }
      },
      "multiplyBytes(bytes16,bytes16)": {
        "params": {
          "x": "The number to be multiplied by `y`",
          "y": "The number to be multiplied by `x`"
        }
      },
      "multiplyDecimalByUInt(bytes16,uint256)": {
        "params": {
          "a": "The first term",
          "b": "The second term"
        },
        "returns": {
          "_0": "The product of a*b as a decimal"
        }
      },
      "processBurnInstantMintCommit(uint256,bytes16,bytes16,bytes16)": {
        "details": "Takes out the burn fee before taking out the mint fee.",
        "params": {
          "amount": "The amount of pool tokens being flipped",
          "burnPrice": "The price of the pool token being burnt",
          "burningFee": "Fee rate for pool token burns",
          "mintingFee": "Fee rate for mints"
        },
        "returns": {
          "_0": "Amount of settlement tokens used to mint.",
          "_1": "The burn fee. This should be given to the side of the pool of the burnt tokens.",
          "_2": "The mint fee. This should be given to the side of the pool that is being minted into."
        }
      },
      "subtractBytes(bytes16,bytes16)": {
        "params": {
          "x": "The number to be subtracted by `y`",
          "y": "The number to subtract from `x`"
        }
      }
    },
    "title": "Library for various useful (mostly) mathematical functions",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "MAX_DECIMALS()": {
        "notice": "Maximum number of decimal places supported by this contract (ABDKMathQuad defines this but it's private)"
      },
      "ONE()": {
        "notice": "ABDKMathQuad-formatted representation of the number one"
      },
      "WAD_PRECISION()": {
        "notice": "Maximum precision supportable via wad arithmetic (for this contract)"
      },
      "addBytes(bytes16,bytes16)": {
        "notice": "Performs an addition on two bytes16 numbers"
      },
      "appropriateUpdateIntervalId(uint256,uint256,uint256,uint256,uint256)": {
        "notice": "Calculates the update interval ID that a commitment should be placed in."
      },
      "calculateValueTransfer(uint256,uint256,bytes16,int256,int256,bytes16)": {
        "notice": "Calculates the effect of a price change. This involves calculating how many funds to transfer from the losing pool to the other."
      },
      "compareDecimals(bytes16,bytes16)": {
        "notice": "Compares two decimal numbers"
      },
      "convertDecimalToUInt(bytes16)": {
        "notice": "Converts a raw decimal value to a more readable uint256 value"
      },
      "convertUIntToDecimal(uint256)": {
        "notice": "Converts an integer value to a compatible decimal value"
      },
      "divInt(int256,int256)": {
        "notice": "Divides two integers"
      },
      "fromWad(uint256,uint256)": {
        "notice": "Converts from a WAD to normal value"
      },
      "getBalancesAfterFees(uint256,uint256,uint256)": {
        "notice": "Gets the short and long balances after the keeper rewards have been paid out         Keeper rewards are paid proportionally to the short and long pool"
      },
      "getBurn(bytes16,uint256)": {
        "notice": "Calculate the number of settlement tokens to return, based on a price and an amount of pool tokens being burnt"
      },
      "getLossAmount(bytes16,uint256)": {
        "notice": "Calculates the amount to take from the losing pool"
      },
      "getLossMultiplier(bytes16,int8,bytes16)": {
        "notice": "Calculates the loss multiplier to apply to the losing pool. Includes the power leverage"
      },
      "getMint(bytes16,uint256)": {
        "notice": "Calculates the number of pool tokens to mint, given some settlement token amount and a price"
      },
      "getMintAmount(uint256,uint256,uint256,uint256)": {
        "notice": "Gets the number of pool tokens to be minted based on existing tokens"
      },
      "getPrice(uint256,uint256)": {
        "notice": "Get the Settlement/PoolToken price, in ABDK IEE754 precision"
      },
      "getRatio(uint256,uint256)": {
        "notice": "Calculates the ratio between two numbers"
      },
      "getUpdatedAggregateBalance(PoolSwapLibrary.UpdateData)": {
        "notice": "Calculate the change in a user's balance based on recent commit(s)"
      },
      "getWithdrawAmountOnBurn(uint256,uint256,uint256,uint256)": {
        "notice": "Gets the number of settlement tokens to be withdrawn based on a pool token burn amount"
      },
      "isBeforeFrontRunningInterval(uint256,uint256,uint256,uint256)": {
        "notice": "Returns true if the given timestamp is BEFORE the frontRunningInterval starts"
      },
      "mintingOrBurningFee(bytes16,uint256)": {
        "notice": "Calculate the amount of settlement tokens to take as the minting fee"
      },
      "mulFraction(uint256,uint256,uint256)": {
        "notice": "Multiply an integer by a fractionnumber * numerator / denominator"
      },
      "multiplyBytes(bytes16,bytes16)": {
        "notice": "Multiplies two numbers"
      },
      "multiplyDecimalByUInt(bytes16,uint256)": {
        "notice": "Multiplies a decimal and an unsigned integer"
      },
      "processBurnInstantMintCommit(uint256,bytes16,bytes16,bytes16)": {
        "notice": "Given an amount of pool tokens to flip to the other side of the pool, calculate the amount of settlement tokens generated from the burn, burn fee, and subsequent minting fee"
      },
      "subtractBytes(bytes16,bytes16)": {
        "notice": "Performs a subtraction on two bytes16 numbers"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}